(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["attributes"] = factory();
	else
		root["CoCreate"] = root["CoCreate"] || {}, root["CoCreate"]["attributes"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "../CoCreate-components/CoCreate-attributes/src/CoCreate-attributes.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../CoCreate-components/CoCreate-attributes/src/CoCreate-attributes.js":
/*!*****************************************************************************!*\
  !*** ../CoCreate-components/CoCreate-attributes/src/CoCreate-attributes.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _common = __webpack_require__(/*! ./common.js */ \"../CoCreate-components/CoCreate-attributes/src/common.js\");\n\n/*global CoCreate*/\nlet profile = [];\n\nfunction profileObserver(mutation, extra = {}) {\n  // get time\n  let date = new Date();\n  let time = date.getSeconds() + '.' + date.getMilliseconds();\n  profile.push({\n    time,\n    ...extra,\n    ...mutation\n  });\n}\n\nlet cache = new _common.elStore(); //todo: refactor to micro requirement\n\nfunction attributes({\n  document: initDocument,\n  exclude = \"\",\n  callback = () => {}\n}) {\n  this.exclude = exclude;\n  this.callback = callback;\n  this.initDocument = initDocument;\n}\n\nattributes.prototype.init = function init() {\n  this.scanNewElement();\n  this.initDocument.defaultView.CoCreate.observer.init({\n    name: \"ccStyle\",\n    observe: [\"attributes\"],\n    attributes: [\"data-attributes_target\", \"value\", \"data-attributes_unit\"],\n    include: \"INPUT, .pickr, cocreate-select\",\n    callback: async m => await this.watchInputChange(m)\n  });\n  this.initDocument.addEventListener(\"input\", async e => {\n    let input = e.target; // input.tagName == \"COCREATE-SELECT\" && \n\n    this.perInput(input, (inputMeta, element) => this.updateElement({ ...inputMeta,\n      input,\n      element,\n      isColl: true\n    }));\n  });\n  this.observerElements(this.initDocument.defaultView);\n  CoCreate.socket.listen(\"ccStyle\", args => this.listen(args));\n};\n\nattributes.prototype.listen = async function listen({\n  value,\n  unit,\n  type,\n  property,\n  camelProperty,\n  elementId,\n  elementSelector\n}) {\n  let input = this.initDocument.querySelector(`[data-attributes=${type}][data-attributes_sync=${property}]:not(${this.exclude})`);\n  let element = await this.complexSelector(elementSelector, (canvasDoc, selector) => canvasDoc.querySelector(selector));\n  this.updateElement({\n    type,\n    property,\n    camelProperty,\n    input,\n    element,\n    collValue: value,\n    unit,\n    isColl: false\n  });\n};\n\nattributes.prototype.collaborate = function collaborate({\n  element,\n  ...rest\n}) {\n  // if (value != input.value) return;\n  let elementId = element.getAttribute('data-element_id');\n  if (!elementId) return console.warn('no element id, collaboration skiped');\n  let elementSelector = rest.input.getAttribute('data-attributes_target');\n  CoCreate.message.send({\n    broadcast_sender: false,\n    rooms: \"\",\n    emit: {\n      message: \"ccStyle\",\n      data: { ...rest,\n        elementId,\n        elementSelector\n      }\n    }\n  });\n};\n\nattributes.prototype.scanNewElement = function scanNewElement() {\n  this.initDocument.querySelectorAll(`[data-attributes][data-attributes_sync]:not(${this.exclude})`).forEach(async input => {\n    this.perInput(input, (inputMeta, element) => this.updateInput({ ...inputMeta,\n      input,\n      element,\n      isColl: true\n    }));\n  });\n};\n\nattributes.prototype.observerElements = function observerElements(initWindow) {\n  initWindow.CoCreate.observer.init({\n    observe: [\"attributes\", \"characterData\"],\n    callback: mutation => {\n      let element = mutation.target;\n      if (!element) return;\n      this.getInputFromElement(mutation.target).forEach(input => {\n        let inputMeta = this.validateInput(input);\n        this.updateInput({ ...inputMeta,\n          input,\n          element\n        });\n      });\n    }\n  });\n}; //convention based (all elements should use data-elememet_id and it's faster)\n// made it also support \"id\"\n\n\nattributes.prototype.getInputFromElement = function getInputFromElement(element) {\n  let elId = element.getAttribute('data-element_id') || element.id && `\"#${element.id}\"`;\n  if (elId) return this.initDocument.querySelectorAll(`[data-attributes_target=${elId}]`);\n  return [];\n}; // todo: discuss with\n// attributes.prototype.getInputFromElement = function getInputFromElement(element) {\n//     // let inputs = [];\n//     //todo: fix add textarea\n//     let elId = element.getAttribute('data-element_id');\n//     if(elId)\n//      this.initDocument.querySelectorAll(`[data-attributes_target]`).forEach\n// }\n\n\nattributes.prototype.watchInputChange = async function watchInputChange(mutation) {\n  try {\n    let element,\n        input = mutation.target;\n    let inputMeta = this.validateInput(input);\n    element = inputMeta && (await this.getElementFromInput(input));\n    if (!element) return;\n\n    if (mutation.attributeName === \"data-attributes_target\") {\n      // if (element) \n      this.updateInput({ ...inputMeta,\n        input,\n        element\n      }); // element.isFirst = element.isFirst === true ? false : true;\n    } else if (mutation.attributeName === \"data-attributes_unit\") {\n      // if (element.isFirst) return;\n      this.updateElement({ ...inputMeta,\n        input,\n        element,\n        isColl: true\n      });\n    }\n  } catch (err) {}\n};\n\nattributes.prototype.perInput = async function perInput(input, callback) {\n  try {\n    let inputMeta, element;\n    inputMeta = this.validateInput(input);\n    element = inputMeta && (await this.getElementFromInput(input));\n    if (!element) return;\n    callback(inputMeta, element);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nattributes.prototype.validateInput = function validateInput(input) {\n  let type = input.getAttribute(\"data-attributes\");\n\n  if (!type) {\n    // console.warn(\"cc-style: input doesn't have data-attributes\")\n    return;\n  }\n\n  let property = input.getAttribute(\"data-attributes_sync\");\n\n  if (!property) {\n    // console.warn(\"cc-style: input doesn't have data-attributes\")\n    return;\n  }\n\n  type = type.toLowerCase();\n  let camelProperty = (0, _common.toCamelCase)(property);\n  property = property.toLowerCase();\n  return {\n    type,\n    property,\n    camelProperty\n  };\n};\n\nattributes.prototype.updateElementByValue = function updateElementByValue({\n  type,\n  property,\n  camelProperty,\n  input,\n  element,\n  inputValue,\n  hasCollValue\n}) {\n  let computedStyles, value, removeValue, hasUpdated, unit;\n\n  switch (type) {\n    case 'property':\n      if (element[camelProperty] != inputValue) {\n        element[camelProperty] = inputValue;\n        return true;\n      } else return false;\n\n    case 'attribute':\n      switch (property) {\n        case 'style':\n          if (typeof inputValue == 'string') {\n            let style = (0, _common.parseCssRules)(inputValue);\n            Object.assign(element.style);\n            return Object.keys(style).length;\n          } else {\n            value = {}, removeValue = {};\n            inputValue.forEach(inputSValue => {\n              let parse = (0, _common.parseCssRules)(inputSValue.value);\n              if (inputSValue.checked) Object.assign(value, parse);else Object.assign(removeValue, parse);\n            });\n            let elStyle = (0, _common.parseCssRules)(element.getAttribute('style'));\n\n            for (let [key, value] of Object.entries(elStyle)) {\n              if (removeValue.hasOwnProperty(key)) delete elStyle[key];\n            }\n\n            Object.assign(elStyle, value);\n            let strStyle = \"\";\n\n            for (let [key, value] of Object.entries(elStyle)) strStyle += `${key}: ${value};`;\n\n            element.setAttribute('style', strStyle); //todo: better way to save elStyle when getting and here to compare\n\n            return Object.keys(elStyle).length;\n          }\n\n        case 'class':\n          if (typeof inputValue == 'string') {\n            let classNames = inputValue.split(' ');\n            classNames.forEach(className => {\n              className && element.classList.add(className);\n            });\n            return classNames.length;\n          } else {\n            value = [], removeValue = [];\n            inputValue.forEach(inputSValue => {\n              let parse = inputSValue.value.split(' ');\n              if (inputSValue.checked) value = value.concat(parse);else removeValue = removeValue.concat(parse);\n            });\n            removeValue.forEach(className => element.classList.remove(className));\n            value.forEach(className => element.classList.add(className)); //todo: fix\n\n            return true;\n          }\n\n        default:\n          if (typeof inputValue == 'string') {\n            return _common.setAttributeIfDif.call(element, property, inputValue);\n          } else {\n            for (let inputSValue of inputValue) {\n              if (inputSValue.checked) {\n                // unconventional change\n                if (property === 'data-attributes_unit' && ['auto', 'inherit', 'initial'].includes(inputSValue.value)) {\n                  element.value = inputSValue.value;\n\n                  _common.removeAllSelectedOptions.call(input);\n                } else // unconventional change\n                  return _common.setAttributeIfDif.call(element, property, inputSValue.value);\n              }\n            }\n          }\n\n          break;\n      }\n\n      break;\n\n    case 'classstyle':\n      unit = input.getAttribute('data-attributes_unit') || '';\n      value = inputValue && !hasCollValue ? inputValue + unit : inputValue;\n      value = value || '';\n      computedStyles = this.getRealStaticCompStyle(element);\n      return (0, _common.setStyleClassIfDif)(element, {\n        property,\n        camelProperty,\n        value,\n        computedStyles\n      });\n\n    case 'style':\n      unit = input.getAttribute('data-attributes_unit') || '';\n      value = inputValue && !hasCollValue ? inputValue + unit : inputValue;\n      value = value || '';\n      computedStyles = this.getRealStaticCompStyle(element);\n      return _common.setStyleIfDif.call(element, {\n        property,\n        camelProperty,\n        value,\n        computedStyles\n      });\n  }\n};\n\nattributes.prototype.updateElement = function updateElement({\n  input,\n  element,\n  collValue,\n  isColl,\n  unit,\n  ...rest\n}) {\n  let inputValue = collValue || this.getInputValue(input);\n  inputValue = unit ? inputValue + unit : inputValue;\n  let hasUpdated = this.updateElementByValue({ ...rest,\n    input,\n    element,\n    inputValue,\n    hasCollValue: !!collValue\n  });\n  cache.reset(element);\n  let params = {\n    value: inputValue,\n    unit: input.getAttribute('data-attributes_unit'),\n    input,\n    element,\n    ...rest\n  };\n  hasUpdated && isColl && this.collaborate(params);\n  hasUpdated && !isColl && this.callback(params); // not needed since crdt\n  // when function called on collboration\n  // todo: use setInputValue directly in updateElementByValue\n  // if (newValue) {\n  //     updateInput({...rest, element, input, })\n  // }\n};\n\nattributes.prototype.updateInput = function updateInput({\n  type,\n  property,\n  camelProperty,\n  element,\n  input\n}) {\n  let computedStyles, value, value2, styleValue, unit;\n  if (!input) return console.error('CoCreate Attributes: input not found/dev');\n\n  switch (type) {\n    case 'property':\n      value = element[camelProperty];\n      break;\n\n    case 'attribute':\n      value = element.getAttribute(property); // setAttributeIfDif.call(input, property, value || '')\n\n      break;\n\n    case 'classstyle':\n      let ccStyle = (0, _common.getCoCreateStyle)(element.classList);\n      if (ccStyle[camelProperty]) value2 = ccStyle[camelProperty];else {\n        computedStyles = this.getRealStaticCompStyle(element);\n        value2 = computedStyles[camelProperty];\n      }\n\n      if (!value2) {\n        return console.warn(`\"${property}\" can not be found in style object`);\n      }\n\n      [styleValue, unit] = (0, _common.parseUnit)(value2);\n      value = styleValue;\n\n      _common.setAttributeIfDif.call(input, \"data-attributes_unit\", unit);\n\n      break;\n\n    case 'style':\n      computedStyles = this.getRealStaticCompStyle(element);\n      value2 = computedStyles[camelProperty];\n\n      if (!value2) {\n        return console.warn(`\"${property}\" can not be found in style object`);\n      }\n\n      [styleValue, unit] = (0, _common.parseUnit)(value2);\n      value = styleValue;\n\n      _common.setAttributeIfDif.call(input, \"data-attributes_unit\", unit);\n\n    default:\n      break;\n  }\n\n  this.setInputValue(input, value);\n};\n\nattributes.prototype.setInputValue = function setInputValue(input, value) {\n  let inputType = input.tagName.toLowerCase() || input.classList.has('.pickr') && 'pickr';\n\n  switch (inputType) {\n    case 'input':\n      switch (input.type) {\n        case 'checkbox':\n        case 'radio':\n          input.checked = value == input.value ? true : false;\n          break;\n\n        default:\n          input.value = value;\n      }\n\n      break;\n\n    case \"textarea\":\n      input.value = value;\n      break;\n\n    case 'select':\n      let options = Array.from(input.options);\n      options.forEach(option => {\n        if (value == option.value) input.selectedIndex = options.indexOf(option);\n      });\n      break;\n\n    case 'cocreate-select':\n      (0, _common.renderOptions)(input, value);\n      break;\n\n    case 'pickr':\n      // todo: how to perform validation\n      let pickrIns = CoCreate.pickr.refs.get(input);\n      CoCreate.pickr.disabledEvent = true;\n      pickrIns.setColor(style);\n      CoCreate.pickr.disabledEvent = false;\n\n    default:\n      console.warn('CoCreateStyle: unidentified input: ', inputType, 'input ', input);\n  }\n};\n\nattributes.prototype.packMultiValue = function packMultiValue({\n  inputs,\n  stateProperty,\n  valueProperty = \"value\",\n  forceState\n}) {\n  let value = [];\n  Array.from(inputs).forEach(input => {\n    value.push({\n      checked: forceState || input[stateProperty],\n      value: input[valueProperty] || input.getAttribute(valueProperty)\n    });\n  });\n  return value;\n};\n\nattributes.prototype.getInputValue = function getInputValue(input) {\n  if (!input) return;\n  let inputType = input.tagName.toLowerCase() || input.classList.has('.pickr') && 'pickr';\n\n  switch (inputType) {\n    case 'input':\n      switch (input.type) {\n        case 'checkbox':\n        case 'radio':\n          return this.packMultiValue({\n            inputs: this.initDocument.getElementsByName(input.name),\n            stateProperty: 'checked'\n          });\n\n        default:\n          return input.value;\n      }\n\n    case \"textarea\":\n      return input.value;\n\n    case 'select':\n      return this.packMultiValue({\n        inputs: input.options,\n        stateProperty: 'selected'\n      });\n\n    case 'cocreate-select':\n      return this.packMultiValue({\n        inputs: input.querySelectorAll(\":scope > [selected]\"),\n        forceState: true\n      });\n\n    case 'pickr':\n      // todo: how to perform validation\n      // if (!CoCreate.pickr.refs.has(input)) return; \n      let pickrIns = CoCreate.pickr.refs.get(input);\n      return pickrIns.getColor().toHEXA().toString();\n\n    default:\n      console.warn('CoCreateStyle: unidentified input');\n      break;\n  }\n};\n\nattributes.prototype.getElementFromInput = async function getElementFromInput(input) {\n  let id = input.getAttribute(\"data-attributes_target\");\n\n  if (id) {\n    if (id.indexOf(';') !== -1) {\n      let el = await this.complexSelector(id, (canvasDoc, selector) => canvasDoc.querySelector(selector));\n      return el;\n    } else return this.initDocument.querySelector(id);\n  } else return false;\n};\n\nattributes.prototype.getRealStaticCompStyle = function getRealStaticCompStyle(element) {\n  if (cache.get(element, 'valid')) return cache.get(element, 'computedStyles');\n  setTimeout(() => {\n    cache.reset(element);\n  }, 5000);\n  let oldDispaly = element.style.display;\n  element.style.display = \"none\";\n  let computedStylesLive = window.getComputedStyle(element);\n  let computedStyles = Object.assign({}, computedStylesLive);\n  computedStyles.display = oldDispaly;\n  element.style.display = oldDispaly;\n  if (element.getAttribute(\"style\") == \"\") element.removeAttribute(\"style\");\n  element.removeAttribute('no-observe');\n  cache.spread(element, {\n    computedStyles,\n    valid: true\n  });\n  return computedStyles;\n};\n\nattributes.prototype.complexSelector = async function complexSelector(comSelector, callback) {\n  let [canvasSelector, selector] = comSelector.split(';');\n  let canvas = document.querySelector(canvasSelector);\n\n  if (!canvas) {\n    console.warn('complex selector canvas now found for', comSelector);\n    return;\n  }\n\n  if (canvas.contentDocument.readyState === 'loading') {\n    try {\n      await new Promise((resolve, reject) => {\n        canvas.contentWindow.addEventListener('load', e => resolve());\n      });\n    } catch (err) {\n      console.error('iframe can not be loaded');\n    }\n  }\n\n  this.observerElements(canvas.contentWindow);\n  return callback(canvas.contentWindow.document, selector);\n}; // attributes.prototype.getInputs = function getInputs(element) {\n//     let inputs = [];\n//     let allInputs = Array.from(document.getElementsByTagName(\"input\"));\n//     allInputs.forEach((inputCandidate) => {\n//         let inputMeta = getInputMetaData(inputCandidate);\n//         if (!inputMeta) return;\n//         let allReferencedEl = allFrame((frame) =>\n//             frame.querySelectorAll(\n//                 inputMeta.input.getAttribute(\"data-attributes_target\")\n//             )\n//         );\n//         if (Array.from(allReferencedEl).includes(element)) {\n//             inputs.push(inputMeta.input);\n//         }\n//     });\n//     return inputs;\n// }\n//attributes.prototype.perInput =  async function perInput(input, callback) {\n//     let inputMeta, element, group = input.getAttribute(\"data-attributes_group\");\n//     if (group) {\n//         [inputMeta, element] = getInputsMetaData(input);\n//     } else {\n//         inputMeta = validateInput(input);\n//         element = await getElementFromInput(input);\n//     }\n//     if (!inputMeta || !element) return;\n//     if (Array.isArray(inputMeta))\n//         inputMeta.forEach(async(metas) => callback(metas, element))\n//     else\n//         callback(inputMeta, element)\n// }\n//attributes.prototype.getInputsMetaData =  function getInputsMetaData(input) {\n//     let list = [],\n//         inputs = [];\n//     let element = getElementFromInput(input)\n//     let realInputs = input.querySelectorAll(group);\n//     realInputs.forEach(inp => {\n//         //todo: group is static \n//         inputs.push(inp)\n//         list.push(validateInput(inp))\n//     })\n//     groupEl.set(input, inputs);\n//     return [list, element];\n// }\n// window.addEventListener('load', () => {\n//     let attribute = new attributes({ document, exclude: '#ghostEffect,.vdom-item ' })\n//     attribute.init()\n// })\n\n\nvar _default = {\n  init: params => {\n    let s = new attributes(params);\n    s.init();\n    return s;\n  }\n};\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5hdHRyaWJ1dGVzLy4uL0NvQ3JlYXRlLWNvbXBvbmVudHMvQ29DcmVhdGUtYXR0cmlidXRlcy9zcmMvQ29DcmVhdGUtYXR0cmlidXRlcy5qcz9kMGYwIl0sIm5hbWVzIjpbInByb2ZpbGUiLCJwcm9maWxlT2JzZXJ2ZXIiLCJtdXRhdGlvbiIsImV4dHJhIiwiZGF0ZSIsIkRhdGUiLCJ0aW1lIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsInB1c2giLCJjYWNoZSIsImVsU3RvcmUiLCJhdHRyaWJ1dGVzIiwiZG9jdW1lbnQiLCJpbml0RG9jdW1lbnQiLCJleGNsdWRlIiwiY2FsbGJhY2siLCJwcm90b3R5cGUiLCJpbml0Iiwic2Nhbk5ld0VsZW1lbnQiLCJkZWZhdWx0VmlldyIsIkNvQ3JlYXRlIiwib2JzZXJ2ZXIiLCJuYW1lIiwib2JzZXJ2ZSIsImluY2x1ZGUiLCJtIiwid2F0Y2hJbnB1dENoYW5nZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiaW5wdXQiLCJ0YXJnZXQiLCJwZXJJbnB1dCIsImlucHV0TWV0YSIsImVsZW1lbnQiLCJ1cGRhdGVFbGVtZW50IiwiaXNDb2xsIiwib2JzZXJ2ZXJFbGVtZW50cyIsInNvY2tldCIsImxpc3RlbiIsImFyZ3MiLCJ2YWx1ZSIsInVuaXQiLCJ0eXBlIiwicHJvcGVydHkiLCJjYW1lbFByb3BlcnR5IiwiZWxlbWVudElkIiwiZWxlbWVudFNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsImNvbXBsZXhTZWxlY3RvciIsImNhbnZhc0RvYyIsInNlbGVjdG9yIiwiY29sbFZhbHVlIiwiY29sbGFib3JhdGUiLCJyZXN0IiwiZ2V0QXR0cmlidXRlIiwiY29uc29sZSIsIndhcm4iLCJtZXNzYWdlIiwic2VuZCIsImJyb2FkY2FzdF9zZW5kZXIiLCJyb29tcyIsImVtaXQiLCJkYXRhIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJ1cGRhdGVJbnB1dCIsImluaXRXaW5kb3ciLCJnZXRJbnB1dEZyb21FbGVtZW50IiwidmFsaWRhdGVJbnB1dCIsImVsSWQiLCJpZCIsImdldEVsZW1lbnRGcm9tSW5wdXQiLCJhdHRyaWJ1dGVOYW1lIiwiZXJyIiwiZXJyb3IiLCJ0b0xvd2VyQ2FzZSIsInVwZGF0ZUVsZW1lbnRCeVZhbHVlIiwiaW5wdXRWYWx1ZSIsImhhc0NvbGxWYWx1ZSIsImNvbXB1dGVkU3R5bGVzIiwicmVtb3ZlVmFsdWUiLCJoYXNVcGRhdGVkIiwic3R5bGUiLCJPYmplY3QiLCJhc3NpZ24iLCJrZXlzIiwibGVuZ3RoIiwiaW5wdXRTVmFsdWUiLCJwYXJzZSIsImNoZWNrZWQiLCJlbFN0eWxlIiwia2V5IiwiZW50cmllcyIsImhhc093blByb3BlcnR5Iiwic3RyU3R5bGUiLCJzZXRBdHRyaWJ1dGUiLCJjbGFzc05hbWVzIiwic3BsaXQiLCJjbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJhZGQiLCJjb25jYXQiLCJyZW1vdmUiLCJzZXRBdHRyaWJ1dGVJZkRpZiIsImNhbGwiLCJpbmNsdWRlcyIsInJlbW92ZUFsbFNlbGVjdGVkT3B0aW9ucyIsImdldFJlYWxTdGF0aWNDb21wU3R5bGUiLCJzZXRTdHlsZUlmRGlmIiwiZ2V0SW5wdXRWYWx1ZSIsInJlc2V0IiwicGFyYW1zIiwidmFsdWUyIiwic3R5bGVWYWx1ZSIsImNjU3R5bGUiLCJzZXRJbnB1dFZhbHVlIiwiaW5wdXRUeXBlIiwidGFnTmFtZSIsImhhcyIsIm9wdGlvbnMiLCJBcnJheSIsImZyb20iLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiaW5kZXhPZiIsInBpY2tySW5zIiwicGlja3IiLCJyZWZzIiwiZ2V0IiwiZGlzYWJsZWRFdmVudCIsInNldENvbG9yIiwicGFja011bHRpVmFsdWUiLCJpbnB1dHMiLCJzdGF0ZVByb3BlcnR5IiwidmFsdWVQcm9wZXJ0eSIsImZvcmNlU3RhdGUiLCJnZXRFbGVtZW50c0J5TmFtZSIsImdldENvbG9yIiwidG9IRVhBIiwidG9TdHJpbmciLCJlbCIsInNldFRpbWVvdXQiLCJvbGREaXNwYWx5IiwiZGlzcGxheSIsImNvbXB1dGVkU3R5bGVzTGl2ZSIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzcHJlYWQiLCJ2YWxpZCIsImNvbVNlbGVjdG9yIiwiY2FudmFzU2VsZWN0b3IiLCJjYW52YXMiLCJjb250ZW50RG9jdW1lbnQiLCJyZWFkeVN0YXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjb250ZW50V2luZG93IiwicyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVBOztBQUZBO0FBc0JBLElBQUlBLE9BQU8sR0FBRyxFQUFkOztBQUVBLFNBQVNDLGVBQVQsQ0FBeUJDLFFBQXpCLEVBQW1DQyxLQUFLLEdBQUcsRUFBM0MsRUFBK0M7QUFFM0M7QUFDQSxNQUFJQyxJQUFJLEdBQUcsSUFBSUMsSUFBSixFQUFYO0FBQ0EsTUFBSUMsSUFBSSxHQUFHRixJQUFJLENBQUNHLFVBQUwsS0FBb0IsR0FBcEIsR0FBMEJILElBQUksQ0FBQ0ksZUFBTCxFQUFyQztBQUNBUixTQUFPLENBQUNTLElBQVIsQ0FBYTtBQUFFSCxRQUFGO0FBQVEsT0FBR0gsS0FBWDtBQUFrQixPQUFHRDtBQUFyQixHQUFiO0FBQ0g7O0FBTUQsSUFBSVEsS0FBSyxHQUFHLElBQUlDLGVBQUosRUFBWixDLENBRUE7O0FBQ0EsU0FBU0MsVUFBVCxDQUFvQjtBQUFFQyxVQUFRLEVBQUVDLFlBQVo7QUFBMEJDLFNBQU8sR0FBRyxFQUFwQztBQUF3Q0MsVUFBUSxHQUFHLE1BQU0sQ0FBRTtBQUEzRCxDQUFwQixFQUFtRjtBQUMvRSxPQUFLRCxPQUFMLEdBQWVBLE9BQWY7QUFDQSxPQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLE9BQUtGLFlBQUwsR0FBb0JBLFlBQXBCO0FBRUg7O0FBR0RGLFVBQVUsQ0FBQ0ssU0FBWCxDQUFxQkMsSUFBckIsR0FBNEIsU0FBU0EsSUFBVCxHQUFnQjtBQUd4QyxPQUFLQyxjQUFMO0FBQ0EsT0FBS0wsWUFBTCxDQUFrQk0sV0FB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O0FBQ0EsWUFBTSxJQUFJQyxPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ25DTCxjQUFNLENBQUNNLGFBQVAsQ0FBcUJuSSxnQkFBckIsQ0FBc0MsTUFBdEMsRUFBK0NDLENBQUQsSUFBT2dJLE9BQU8sRUFBNUQ7QUFDSCxPQUZLLENBQU47QUFHSCxLQUpELENBS0EsT0FBT25GLEdBQVAsRUFBWTtBQUNSbEIsYUFBTyxDQUFDbUIsS0FBUixDQUFjLDBCQUFkO0FBQ0g7QUFFSjs7QUFDRCxPQUFLdEMsZ0JBQUwsQ0FBc0JvSCxNQUFNLENBQUNNLGFBQTdCO0FBQ0EsU0FBTy9JLFFBQVEsQ0FBQ3lJLE1BQU0sQ0FBQ00sYUFBUCxDQUFxQmxKLFFBQXRCLEVBQWdDc0MsUUFBaEMsQ0FBZjtBQUNILENBcEJELEMsQ0E0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7ZUFFZTtBQUNYakMsTUFBSSxFQUFHOEYsTUFBRCxJQUFZO0FBQ2QsUUFBSWdELENBQUMsR0FBRyxJQUFJcEosVUFBSixDQUFlb0csTUFBZixDQUFSO0FBQ0FnRCxLQUFDLENBQUM5SSxJQUFGO0FBQ0EsV0FBTzhJLENBQVA7QUFDSDtBQUxVLEMiLCJmaWxlIjoiLi4vQ29DcmVhdGUtY29tcG9uZW50cy9Db0NyZWF0ZS1hdHRyaWJ1dGVzL3NyYy9Db0NyZWF0ZS1hdHRyaWJ1dGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgQ29DcmVhdGUqL1xuXG5pbXBvcnQge1xuICAgIGVsU3RvcmUsXG4gICAgcGFyc2VDc3NSdWxlcyxcbiAgICByZW5kZXJPcHRpb25zLFxuICAgIHJlbW92ZUFsbFNlbGVjdGVkT3B0aW9ucyxcbiAgICBzZXRTdHlsZUlmRGlmLFxuICAgIHNldEF0dHJpYnV0ZUlmRGlmLFxuICAgIHNldFN0eWxlQ2xhc3NJZkRpZixcbiAgICBnZXRDb0NyZWF0ZVN0eWxlLFxuICAgIHRvQ2FtZWxDYXNlLFxuICAgIHBhcnNlVW5pdCxcbiAgICByZ2JhMmhleFxufVxuZnJvbSAnLi9jb21tb24uanMnO1xuXG5cblxuXG5cblxubGV0IHByb2ZpbGUgPSBbXVxuXG5mdW5jdGlvbiBwcm9maWxlT2JzZXJ2ZXIobXV0YXRpb24sIGV4dHJhID0ge30pIHtcblxuICAgIC8vIGdldCB0aW1lXG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCB0aW1lID0gZGF0ZS5nZXRTZWNvbmRzKCkgKyAnLicgKyBkYXRlLmdldE1pbGxpc2Vjb25kcygpXG4gICAgcHJvZmlsZS5wdXNoKHsgdGltZSwgLi4uZXh0cmEsIC4uLm11dGF0aW9uIH0pXG59XG5cblxuXG5cblxubGV0IGNhY2hlID0gbmV3IGVsU3RvcmUoKTtcblxuLy90b2RvOiByZWZhY3RvciB0byBtaWNybyByZXF1aXJlbWVudFxuZnVuY3Rpb24gYXR0cmlidXRlcyh7IGRvY3VtZW50OiBpbml0RG9jdW1lbnQsIGV4Y2x1ZGUgPSBcIlwiLCBjYWxsYmFjayA9ICgpID0+IHt9IH0pIHtcbiAgICB0aGlzLmV4Y2x1ZGUgPSBleGNsdWRlO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmluaXREb2N1bWVudCA9IGluaXREb2N1bWVudDtcblxufVxuXG5cbmF0dHJpYnV0ZXMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuXG5cbiAgICB0aGlzLnNjYW5OZXdFbGVtZW50KClcbiAgICB0aGlzLmluaXREb2N1bWVudC5kZWZhdWx0Vmlldy5Db0NyZWF0ZS5vYnNlcnZlci5pbml0KHtcbiAgICAgICAgbmFtZTogXCJjY1N0eWxlXCIsXG4gICAgICAgIG9ic2VydmU6IFtcImF0dHJpYnV0ZXNcIl0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IFtcImRhdGEtYXR0cmlidXRlc190YXJnZXRcIiwgXCJ2YWx1ZVwiLCBcImRhdGEtYXR0cmlidXRlc191bml0XCJdLFxuICAgICAgICBpbmNsdWRlOiBcIklOUFVULCAucGlja3IsIGNvY3JlYXRlLXNlbGVjdFwiLFxuICAgICAgICBjYWxsYmFjazogYXN5bmMgbSA9PiBhd2FpdCB0aGlzLndhdGNoSW5wdXRDaGFuZ2UobSksXG4gICAgfSk7XG4gICAgdGhpcy5pbml0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGFzeW5jKGUpID0+IHtcbiAgICAgICAgbGV0IGlucHV0ID0gZS50YXJnZXQ7XG4gICAgICAgIC8vIGlucHV0LnRhZ05hbWUgPT0gXCJDT0NSRUFURS1TRUxFQ1RcIiAmJiBcbiAgICAgICAgdGhpcy5wZXJJbnB1dChpbnB1dCwgKGlucHV0TWV0YSwgZWxlbWVudCkgPT5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCh7IC4uLmlucHV0TWV0YSwgaW5wdXQsIGVsZW1lbnQsIGlzQ29sbDogdHJ1ZSB9KSlcbiAgICB9KTtcblxuICAgIHRoaXMub2JzZXJ2ZXJFbGVtZW50cyh0aGlzLmluaXREb2N1bWVudC5kZWZhdWx0Vmlldyk7XG5cbiAgICBDb0NyZWF0ZS5zb2NrZXQubGlzdGVuKFwiY2NTdHlsZVwiLCAoYXJncykgPT4gdGhpcy5saXN0ZW4oYXJncykpO1xuXG5cblxufVxuXG5cbmF0dHJpYnV0ZXMucHJvdG90eXBlLmxpc3RlbiA9IGFzeW5jIGZ1bmN0aW9uIGxpc3Rlbih7XG4gICAgdmFsdWUsXG4gICAgdW5pdCxcbiAgICB0eXBlLFxuICAgIHByb3BlcnR5LFxuICAgIGNhbWVsUHJvcGVydHksXG4gICAgZWxlbWVudElkLFxuICAgIGVsZW1lbnRTZWxlY3RvclxufSkge1xuXG4gICAgbGV0IGlucHV0ID0gdGhpcy5pbml0RG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgYFtkYXRhLWF0dHJpYnV0ZXM9JHt0eXBlfV1bZGF0YS1hdHRyaWJ1dGVzX3N5bmM9JHtwcm9wZXJ0eX1dOm5vdCgke3RoaXMuZXhjbHVkZX0pYFxuICAgICk7XG5cbiAgICBsZXQgZWxlbWVudCA9IGF3YWl0IHRoaXMuY29tcGxleFNlbGVjdG9yKGVsZW1lbnRTZWxlY3RvcixcbiAgICAgICAgKGNhbnZhc0RvYywgc2VsZWN0b3IpID0+IGNhbnZhc0RvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSk7XG5cblxuICAgIHRoaXMudXBkYXRlRWxlbWVudCh7IHR5cGUsIHByb3BlcnR5LCBjYW1lbFByb3BlcnR5LCBpbnB1dCwgZWxlbWVudCwgY29sbFZhbHVlOiB2YWx1ZSwgdW5pdCwgaXNDb2xsOiBmYWxzZSB9KVxuXG5cbn1cblxuYXR0cmlidXRlcy5wcm90b3R5cGUuY29sbGFib3JhdGUgPSBmdW5jdGlvbiBjb2xsYWJvcmF0ZSh7XG4gICAgZWxlbWVudCxcbiAgICAuLi5yZXN0XG59KSB7XG4gICAgLy8gaWYgKHZhbHVlICE9IGlucHV0LnZhbHVlKSByZXR1cm47XG4gICAgbGV0IGVsZW1lbnRJZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWVsZW1lbnRfaWQnKTtcbiAgICBpZiAoIWVsZW1lbnRJZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2Fybignbm8gZWxlbWVudCBpZCwgY29sbGFib3JhdGlvbiBza2lwZWQnKTtcbiAgICBsZXQgZWxlbWVudFNlbGVjdG9yID0gcmVzdC5pbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYXR0cmlidXRlc190YXJnZXQnKTtcblxuXG5cbiAgICBDb0NyZWF0ZS5tZXNzYWdlLnNlbmQoe1xuICAgICAgICBicm9hZGNhc3Rfc2VuZGVyOiBmYWxzZSxcbiAgICAgICAgcm9vbXM6IFwiXCIsXG4gICAgICAgIGVtaXQ6IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiY2NTdHlsZVwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAgICAgZWxlbWVudElkLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRTZWxlY3RvclxuICAgICAgICAgICAgfSxcblxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5hdHRyaWJ1dGVzLnByb3RvdHlwZS5zY2FuTmV3RWxlbWVudCA9IGZ1bmN0aW9uIHNjYW5OZXdFbGVtZW50KCkge1xuICAgIHRoaXMuaW5pdERvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLWF0dHJpYnV0ZXNdW2RhdGEtYXR0cmlidXRlc19zeW5jXTpub3QoJHt0aGlzLmV4Y2x1ZGV9KWApLmZvckVhY2goYXN5bmMoaW5wdXQpID0+IHtcbiAgICAgICAgdGhpcy5wZXJJbnB1dChpbnB1dCwgKGlucHV0TWV0YSwgZWxlbWVudCkgPT5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5wdXQoeyAuLi5pbnB1dE1ldGEsIGlucHV0LCBlbGVtZW50LCBpc0NvbGw6IHRydWUgfSkpXG4gICAgfSk7XG59XG5hdHRyaWJ1dGVzLnByb3RvdHlwZS5vYnNlcnZlckVsZW1lbnRzID0gZnVuY3Rpb24gb2JzZXJ2ZXJFbGVtZW50cyhpbml0V2luZG93KSB7XG4gICAgaW5pdFdpbmRvdy5Db0NyZWF0ZS5vYnNlcnZlci5pbml0KHtcbiAgICAgICAgb2JzZXJ2ZTogW1wiYXR0cmlidXRlc1wiLCBcImNoYXJhY3RlckRhdGFcIl0sXG4gICAgICAgIGNhbGxiYWNrOiAobXV0YXRpb24pID0+IHtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmdldElucHV0RnJvbUVsZW1lbnQobXV0YXRpb24udGFyZ2V0KS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXRNZXRhID0gdGhpcy52YWxpZGF0ZUlucHV0KGlucHV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlucHV0KHsgLi4uaW5wdXRNZXRhLCBpbnB1dCwgZWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLy9jb252ZW50aW9uIGJhc2VkIChhbGwgZWxlbWVudHMgc2hvdWxkIHVzZSBkYXRhLWVsZW1lbWV0X2lkIGFuZCBpdCdzIGZhc3Rlcilcbi8vIG1hZGUgaXQgYWxzbyBzdXBwb3J0IFwiaWRcIlxuYXR0cmlidXRlcy5wcm90b3R5cGUuZ2V0SW5wdXRGcm9tRWxlbWVudCA9IGZ1bmN0aW9uIGdldElucHV0RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuXG5cbiAgICBsZXQgZWxJZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWVsZW1lbnRfaWQnKSB8fCBlbGVtZW50LmlkICYmIGBcIiMke2VsZW1lbnQuaWQgfVwiYDtcbiAgICBpZiAoZWxJZClcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdERvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLWF0dHJpYnV0ZXNfdGFyZ2V0PSR7ZWxJZH1dYClcbiAgICByZXR1cm4gW11cblxufVxuXG4vLyB0b2RvOiBkaXNjdXNzIHdpdGhcbi8vIGF0dHJpYnV0ZXMucHJvdG90eXBlLmdldElucHV0RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiBnZXRJbnB1dEZyb21FbGVtZW50KGVsZW1lbnQpIHtcblxuLy8gICAgIC8vIGxldCBpbnB1dHMgPSBbXTtcblxuLy8gICAgIC8vdG9kbzogZml4IGFkZCB0ZXh0YXJlYVxuLy8gICAgIGxldCBlbElkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZWxlbWVudF9pZCcpO1xuLy8gICAgIGlmKGVsSWQpXG4vLyAgICAgIHRoaXMuaW5pdERvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLWF0dHJpYnV0ZXNfdGFyZ2V0XWApLmZvckVhY2hcblxuLy8gfVxuXG5hdHRyaWJ1dGVzLnByb3RvdHlwZS53YXRjaElucHV0Q2hhbmdlID0gYXN5bmMgZnVuY3Rpb24gd2F0Y2hJbnB1dENoYW5nZShtdXRhdGlvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBlbGVtZW50LCBpbnB1dCA9IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgbGV0IGlucHV0TWV0YSA9IHRoaXMudmFsaWRhdGVJbnB1dChpbnB1dCk7XG5cblxuICAgICAgICBlbGVtZW50ID0gaW5wdXRNZXRhICYmIGF3YWl0IHRoaXMuZ2V0RWxlbWVudEZyb21JbnB1dChpbnB1dCk7XG5cbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm5cblxuXG4gICAgICAgIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSBcImRhdGEtYXR0cmlidXRlc190YXJnZXRcIikge1xuICAgICAgICAgICAgLy8gaWYgKGVsZW1lbnQpIFxuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dCh7IC4uLmlucHV0TWV0YSwgaW5wdXQsIGVsZW1lbnQgfSk7XG4gICAgICAgICAgICAvLyBlbGVtZW50LmlzRmlyc3QgPSBlbGVtZW50LmlzRmlyc3QgPT09IHRydWUgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gXCJkYXRhLWF0dHJpYnV0ZXNfdW5pdFwiKSB7XG4gICAgICAgICAgICAvLyBpZiAoZWxlbWVudC5pc0ZpcnN0KSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoeyAuLi5pbnB1dE1ldGEsIGlucHV0LCBlbGVtZW50LCBpc0NvbGw6IHRydWUgfSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG5cbiAgICB9XG5cbn1cblxuXG5hdHRyaWJ1dGVzLnByb3RvdHlwZS5wZXJJbnB1dCA9IGFzeW5jIGZ1bmN0aW9uIHBlcklucHV0KGlucHV0LCBjYWxsYmFjaykge1xuXG5cbiAgICB0cnkge1xuICAgICAgICBsZXQgaW5wdXRNZXRhLCBlbGVtZW50O1xuICAgICAgICBpbnB1dE1ldGEgPSB0aGlzLnZhbGlkYXRlSW5wdXQoaW5wdXQpO1xuICAgICAgICBlbGVtZW50ID0gaW5wdXRNZXRhICYmIGF3YWl0IHRoaXMuZ2V0RWxlbWVudEZyb21JbnB1dChpbnB1dCk7XG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICAgICAgICBjYWxsYmFjayhpbnB1dE1ldGEsIGVsZW1lbnQpXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICAgIH1cblxufVxuXG5cblxuXG5hdHRyaWJ1dGVzLnByb3RvdHlwZS52YWxpZGF0ZUlucHV0ID0gZnVuY3Rpb24gdmFsaWRhdGVJbnB1dChpbnB1dCkge1xuICAgIGxldCB0eXBlID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1hdHRyaWJ1dGVzXCIpO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJjYy1zdHlsZTogaW5wdXQgZG9lc24ndCBoYXZlIGRhdGEtYXR0cmlidXRlc1wiKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcm9wZXJ0eSA9IGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtYXR0cmlidXRlc19zeW5jXCIpO1xuICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKFwiY2Mtc3R5bGU6IGlucHV0IGRvZXNuJ3QgaGF2ZSBkYXRhLWF0dHJpYnV0ZXNcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IGNhbWVsUHJvcGVydHkgPSB0b0NhbWVsQ2FzZShwcm9wZXJ0eSk7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgY2FtZWxQcm9wZXJ0eSxcblxuICAgIH07XG59XG5cblxuYXR0cmlidXRlcy5wcm90b3R5cGUudXBkYXRlRWxlbWVudEJ5VmFsdWUgPSBmdW5jdGlvbiB1cGRhdGVFbGVtZW50QnlWYWx1ZSh7IHR5cGUsIHByb3BlcnR5LCBjYW1lbFByb3BlcnR5LCBpbnB1dCwgZWxlbWVudCwgaW5wdXRWYWx1ZSwgaGFzQ29sbFZhbHVlIH0pIHtcbiAgICBsZXQgY29tcHV0ZWRTdHlsZXMsIHZhbHVlLCByZW1vdmVWYWx1ZSwgaGFzVXBkYXRlZCwgdW5pdDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncHJvcGVydHknOlxuICAgICAgICAgICAgaWYgKGVsZW1lbnRbY2FtZWxQcm9wZXJ0eV0gIT0gaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbY2FtZWxQcm9wZXJ0eV0gPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSAnYXR0cmlidXRlJzpcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRWYWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gcGFyc2VDc3NSdWxlcyhpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlKS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge30sIHJlbW92ZVZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlLmZvckVhY2goaW5wdXRTVmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZSA9IHBhcnNlQ3NzUnVsZXMoaW5wdXRTVmFsdWUudmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U1ZhbHVlLmNoZWNrZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmFsdWUsIHBhcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVtb3ZlVmFsdWUsIHBhcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxTdHlsZSA9IHBhcnNlQ3NzUnVsZXMoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZWxTdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsU3R5bGVba2V5XVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGVsU3R5bGUsIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0clN0eWxlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhlbFN0eWxlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJTdHlsZSArPSBgJHtrZXl9OiAke3ZhbHVlfTtgXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHJTdHlsZSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy90b2RvOiBiZXR0ZXIgd2F5IHRvIHNhdmUgZWxTdHlsZSB3aGVuIGdldHRpbmcgYW5kIGhlcmUgdG8gY29tcGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGVsU3R5bGUpLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0VmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWVzID0gaW5wdXRWYWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLCByZW1vdmVWYWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZS5mb3JFYWNoKGlucHV0U1ZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2UgPSBpbnB1dFNWYWx1ZS52YWx1ZS5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U1ZhbHVlLmNoZWNrZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY29uY2F0KHBhcnNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVmFsdWUgPSByZW1vdmVWYWx1ZS5jb25jYXQocGFyc2UpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVWYWx1ZS5mb3JFYWNoKGNsYXNzTmFtZSA9PiBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goY2xhc3NOYW1lID0+IGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RvZG86IGZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG5cblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRWYWx1ZSA9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0QXR0cmlidXRlSWZEaWYuY2FsbChlbGVtZW50LCBwcm9wZXJ0eSwgaW5wdXRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlucHV0U1ZhbHVlIG9mIGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRTVmFsdWUuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmNvbnZlbnRpb25hbCBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnZGF0YS1hdHRyaWJ1dGVzX3VuaXQnICYmIFsnYXV0bycsICdpbmhlcml0JywgJ2luaXRpYWwnXS5pbmNsdWRlcyhpbnB1dFNWYWx1ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBpbnB1dFNWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUFsbFNlbGVjdGVkT3B0aW9ucy5jYWxsKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuY29udmVudGlvbmFsIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZUlmRGlmLmNhbGwoZWxlbWVudCwgcHJvcGVydHksIGlucHV0U1ZhbHVlLnZhbHVlKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjbGFzc3N0eWxlJzpcbiAgICAgICAgICAgIHVuaXQgPSAoaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWF0dHJpYnV0ZXNfdW5pdCcpIHx8ICcnKTtcbiAgICAgICAgICAgIHZhbHVlID0gaW5wdXRWYWx1ZSAmJiAhaGFzQ29sbFZhbHVlID8gaW5wdXRWYWx1ZSArIHVuaXQgOiBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgIGNvbXB1dGVkU3R5bGVzID0gdGhpcy5nZXRSZWFsU3RhdGljQ29tcFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHNldFN0eWxlQ2xhc3NJZkRpZihlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgY2FtZWxQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZFN0eWxlc1xuICAgICAgICAgICAgfSlcblxuXG4gICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgIHVuaXQgPSAoaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWF0dHJpYnV0ZXNfdW5pdCcpIHx8ICcnKTtcbiAgICAgICAgICAgIHZhbHVlID0gaW5wdXRWYWx1ZSAmJiAhaGFzQ29sbFZhbHVlID8gaW5wdXRWYWx1ZSArIHVuaXQgOiBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgIGNvbXB1dGVkU3R5bGVzID0gdGhpcy5nZXRSZWFsU3RhdGljQ29tcFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHNldFN0eWxlSWZEaWYuY2FsbChlbGVtZW50LCB7IHByb3BlcnR5LCBjYW1lbFByb3BlcnR5LCB2YWx1ZSwgY29tcHV0ZWRTdHlsZXMgfSlcblxuICAgIH1cblxuXG59XG5cbmF0dHJpYnV0ZXMucHJvdG90eXBlLnVwZGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHsgaW5wdXQsIGVsZW1lbnQsIGNvbGxWYWx1ZSwgaXNDb2xsLCB1bml0LCAuLi5yZXN0IH0pIHtcblxuXG4gICAgbGV0IGlucHV0VmFsdWUgPSBjb2xsVmFsdWUgfHwgdGhpcy5nZXRJbnB1dFZhbHVlKGlucHV0KTtcbiAgICBpbnB1dFZhbHVlID0gdW5pdCA/IGlucHV0VmFsdWUgKyB1bml0IDogaW5wdXRWYWx1ZTtcbiAgICBsZXQgaGFzVXBkYXRlZCA9IHRoaXMudXBkYXRlRWxlbWVudEJ5VmFsdWUoeyAuLi5yZXN0LCBpbnB1dCwgZWxlbWVudCwgaW5wdXRWYWx1ZSwgaGFzQ29sbFZhbHVlOiAhIWNvbGxWYWx1ZSB9KVxuXG4gICAgY2FjaGUucmVzZXQoZWxlbWVudClcblxuXG4gICAgbGV0IHBhcmFtcyA9IHtcbiAgICAgICAgdmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgIHVuaXQ6IGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS1hdHRyaWJ1dGVzX3VuaXQnKSxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIC4uLnJlc3RcbiAgICB9O1xuXG4gICAgaGFzVXBkYXRlZCAmJlxuICAgICAgICBpc0NvbGwgJiZcbiAgICAgICAgdGhpcy5jb2xsYWJvcmF0ZShwYXJhbXMpO1xuICAgICAgICBcbiAgICBoYXNVcGRhdGVkICYmXG4gICAgICAgICFpc0NvbGwgJiZcbiAgICAgICAgdGhpcy5jYWxsYmFjayhwYXJhbXMpO1xuXG4gICAgLy8gbm90IG5lZWRlZCBzaW5jZSBjcmR0XG4gICAgLy8gd2hlbiBmdW5jdGlvbiBjYWxsZWQgb24gY29sbGJvcmF0aW9uXG4gICAgLy8gdG9kbzogdXNlIHNldElucHV0VmFsdWUgZGlyZWN0bHkgaW4gdXBkYXRlRWxlbWVudEJ5VmFsdWVcbiAgICAvLyBpZiAobmV3VmFsdWUpIHtcbiAgICAvLyAgICAgdXBkYXRlSW5wdXQoey4uLnJlc3QsIGVsZW1lbnQsIGlucHV0LCB9KVxuICAgIC8vIH1cblxufVxuXG5hdHRyaWJ1dGVzLnByb3RvdHlwZS51cGRhdGVJbnB1dCA9IGZ1bmN0aW9uIHVwZGF0ZUlucHV0KHsgdHlwZSwgcHJvcGVydHksIGNhbWVsUHJvcGVydHksIGVsZW1lbnQsIGlucHV0IH0pIHtcbiAgICBsZXQgY29tcHV0ZWRTdHlsZXMsIHZhbHVlLCB2YWx1ZTIsIHN0eWxlVmFsdWUsIHVuaXQ7XG4gICAgaWYgKCFpbnB1dCkgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ0NvQ3JlYXRlIEF0dHJpYnV0ZXM6IGlucHV0IG5vdCBmb3VuZC9kZXYnKVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwcm9wZXJ0eSc6XG4gICAgICAgICAgICB2YWx1ZSA9IGVsZW1lbnRbY2FtZWxQcm9wZXJ0eV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXR0cmlidXRlJzpcbiAgICAgICAgICAgIHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUocHJvcGVydHkpO1xuICAgICAgICAgICAgLy8gc2V0QXR0cmlidXRlSWZEaWYuY2FsbChpbnB1dCwgcHJvcGVydHksIHZhbHVlIHx8ICcnKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NsYXNzc3R5bGUnOlxuICAgICAgICAgICAgbGV0IGNjU3R5bGUgPSBnZXRDb0NyZWF0ZVN0eWxlKGVsZW1lbnQuY2xhc3NMaXN0KTtcbiAgICAgICAgICAgIGlmIChjY1N0eWxlW2NhbWVsUHJvcGVydHldKVxuICAgICAgICAgICAgICAgIHZhbHVlMiA9IGNjU3R5bGVbY2FtZWxQcm9wZXJ0eV07XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlZFN0eWxlcyA9IHRoaXMuZ2V0UmVhbFN0YXRpY0NvbXBTdHlsZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YWx1ZTIgPSBjb21wdXRlZFN0eWxlc1tjYW1lbFByb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsdWUyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgXCIke3Byb3BlcnR5fVwiIGNhbiBub3QgYmUgZm91bmQgaW4gc3R5bGUgb2JqZWN0YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChbc3R5bGVWYWx1ZSwgdW5pdF0gPSBwYXJzZVVuaXQodmFsdWUyKSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0eWxlVmFsdWU7XG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGVJZkRpZi5jYWxsKGlucHV0LCBcImRhdGEtYXR0cmlidXRlc191bml0XCIsIHVuaXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgIGNvbXB1dGVkU3R5bGVzID0gdGhpcy5nZXRSZWFsU3RhdGljQ29tcFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICAgICAgdmFsdWUyID0gY29tcHV0ZWRTdHlsZXNbY2FtZWxQcm9wZXJ0eV07XG4gICAgICAgICAgICBpZiAoIXZhbHVlMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYFwiJHtwcm9wZXJ0eX1cIiBjYW4gbm90IGJlIGZvdW5kIGluIHN0eWxlIG9iamVjdGApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoW3N0eWxlVmFsdWUsIHVuaXRdID0gcGFyc2VVbml0KHZhbHVlMikpO1xuICAgICAgICAgICAgdmFsdWUgPSBzdHlsZVZhbHVlO1xuICAgICAgICAgICAgc2V0QXR0cmlidXRlSWZEaWYuY2FsbChpbnB1dCwgXCJkYXRhLWF0dHJpYnV0ZXNfdW5pdFwiLCB1bml0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuc2V0SW5wdXRWYWx1ZShpbnB1dCwgdmFsdWUpO1xuXG59XG5cbmF0dHJpYnV0ZXMucHJvdG90eXBlLnNldElucHV0VmFsdWUgPSBmdW5jdGlvbiBzZXRJbnB1dFZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIGxldCBpbnB1dFR5cGUgPSBpbnB1dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgfHwgaW5wdXQuY2xhc3NMaXN0LmhhcygnLnBpY2tyJykgJiYgJ3BpY2tyJztcblxuICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PSBpbnB1dC52YWx1ZSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICAgIGxldCBvcHRpb25zID0gQXJyYXkuZnJvbShpbnB1dC5vcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG9wdGlvbi52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2VsZWN0ZWRJbmRleCA9IG9wdGlvbnMuaW5kZXhPZihvcHRpb24pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb2NyZWF0ZS1zZWxlY3QnOlxuICAgICAgICAgICAgcmVuZGVyT3B0aW9ucyhpbnB1dCwgdmFsdWUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncGlja3InOlxuICAgICAgICAgICAgLy8gdG9kbzogaG93IHRvIHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAgICAgICAgbGV0IHBpY2tySW5zID0gQ29DcmVhdGUucGlja3IucmVmcy5nZXQoaW5wdXQpO1xuICAgICAgICAgICAgQ29DcmVhdGUucGlja3IuZGlzYWJsZWRFdmVudCA9IHRydWU7XG4gICAgICAgICAgICBwaWNrcklucy5zZXRDb2xvcihzdHlsZSk7XG4gICAgICAgICAgICBDb0NyZWF0ZS5waWNrci5kaXNhYmxlZEV2ZW50ID0gZmFsc2U7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29DcmVhdGVTdHlsZTogdW5pZGVudGlmaWVkIGlucHV0OiAnLCBpbnB1dFR5cGUsICdpbnB1dCAnLCBpbnB1dClcbiAgICB9XG59XG5cblxuXG5cbmF0dHJpYnV0ZXMucHJvdG90eXBlLnBhY2tNdWx0aVZhbHVlID0gZnVuY3Rpb24gcGFja011bHRpVmFsdWUoe1xuICAgIGlucHV0cyxcbiAgICBzdGF0ZVByb3BlcnR5LFxuICAgIHZhbHVlUHJvcGVydHkgPSBcInZhbHVlXCIsXG4gICAgZm9yY2VTdGF0ZSxcbn0pIHtcbiAgICBsZXQgdmFsdWUgPSBbXTtcbiAgICBBcnJheS5mcm9tKGlucHV0cykuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIHZhbHVlLnB1c2goeyBjaGVja2VkOiBmb3JjZVN0YXRlIHx8IGlucHV0W3N0YXRlUHJvcGVydHldLCB2YWx1ZTogaW5wdXRbdmFsdWVQcm9wZXJ0eV0gfHwgaW5wdXQuZ2V0QXR0cmlidXRlKHZhbHVlUHJvcGVydHkpIH0pXG4gICAgfSlcbiAgICByZXR1cm4gdmFsdWVcbn1cblxuYXR0cmlidXRlcy5wcm90b3R5cGUuZ2V0SW5wdXRWYWx1ZSA9IGZ1bmN0aW9uIGdldElucHV0VmFsdWUoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSByZXR1cm47XG4gICAgbGV0IGlucHV0VHlwZSA9IGlucHV0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSB8fCBpbnB1dC5jbGFzc0xpc3QuaGFzKCcucGlja3InKSAmJiAncGlja3InO1xuXG4gICAgc3dpdGNoIChpbnB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAgICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFja011bHRpVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmluaXREb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShpbnB1dC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUHJvcGVydHk6ICdjaGVja2VkJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQudmFsdWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC52YWx1ZTtcblxuICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFja011bHRpVmFsdWUoe1xuICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXQub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzdGF0ZVByb3BlcnR5OiAnc2VsZWN0ZWQnXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgJ2NvY3JlYXRlLXNlbGVjdCc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWNrTXVsdGlWYWx1ZSh7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dC5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gW3NlbGVjdGVkXVwiKSxcbiAgICAgICAgICAgICAgICBmb3JjZVN0YXRlOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdwaWNrcic6XG4gICAgICAgICAgICAvLyB0b2RvOiBob3cgdG8gcGVyZm9ybSB2YWxpZGF0aW9uXG4gICAgICAgICAgICAvLyBpZiAoIUNvQ3JlYXRlLnBpY2tyLnJlZnMuaGFzKGlucHV0KSkgcmV0dXJuOyBcbiAgICAgICAgICAgIGxldCBwaWNrcklucyA9IENvQ3JlYXRlLnBpY2tyLnJlZnMuZ2V0KGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBwaWNrcklucy5nZXRDb2xvcigpLnRvSEVYQSgpLnRvU3RyaW5nKCk7XG5cblxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvQ3JlYXRlU3R5bGU6IHVuaWRlbnRpZmllZCBpbnB1dCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG5cbn1cblxuXG5cbmF0dHJpYnV0ZXMucHJvdG90eXBlLmdldEVsZW1lbnRGcm9tSW5wdXQgPSBhc3luYyBmdW5jdGlvbiBnZXRFbGVtZW50RnJvbUlucHV0KGlucHV0KSB7XG4gICAgbGV0IGlkID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1hdHRyaWJ1dGVzX3RhcmdldFwiKTtcblxuICAgIGlmIChpZCkge1xuICAgICAgICBpZiAoaWQuaW5kZXhPZignOycpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IGVsID0gYXdhaXQgdGhpcy5jb21wbGV4U2VsZWN0b3IoaWQsXG4gICAgICAgICAgICAgICAgKGNhbnZhc0RvYywgc2VsZWN0b3IpID0+IGNhbnZhc0RvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdERvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaWQpXG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG59XG5cblxuXG5hdHRyaWJ1dGVzLnByb3RvdHlwZS5nZXRSZWFsU3RhdGljQ29tcFN0eWxlID0gZnVuY3Rpb24gZ2V0UmVhbFN0YXRpY0NvbXBTdHlsZShlbGVtZW50KSB7XG4gICAgaWYgKGNhY2hlLmdldChlbGVtZW50LCAndmFsaWQnKSlcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChlbGVtZW50LCAnY29tcHV0ZWRTdHlsZXMnKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2FjaGUucmVzZXQoZWxlbWVudClcbiAgICB9LCA1MDAwKTtcbiAgICBsZXQgb2xkRGlzcGFseSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheTtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBsZXQgY29tcHV0ZWRTdHlsZXNMaXZlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgbGV0IGNvbXB1dGVkU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7fSwgY29tcHV0ZWRTdHlsZXNMaXZlKTtcbiAgICBjb21wdXRlZFN0eWxlcy5kaXNwbGF5ID0gb2xkRGlzcGFseTtcblxuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IG9sZERpc3BhbHk7XG4gICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgPT0gXCJcIikgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnbm8tb2JzZXJ2ZScpXG4gICAgY2FjaGUuc3ByZWFkKGVsZW1lbnQsIHsgY29tcHV0ZWRTdHlsZXMsIHZhbGlkOiB0cnVlIH0pXG4gICAgcmV0dXJuIGNvbXB1dGVkU3R5bGVzO1xufVxuXG5cbmF0dHJpYnV0ZXMucHJvdG90eXBlLmNvbXBsZXhTZWxlY3RvciA9IGFzeW5jIGZ1bmN0aW9uIGNvbXBsZXhTZWxlY3Rvcihjb21TZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICBsZXQgW2NhbnZhc1NlbGVjdG9yLCBzZWxlY3Rvcl0gPSBjb21TZWxlY3Rvci5zcGxpdCgnOycpO1xuICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNhbnZhc1NlbGVjdG9yKTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2NvbXBsZXggc2VsZWN0b3IgY2FudmFzIG5vdyBmb3VuZCBmb3InLCBjb21TZWxlY3RvcilcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjYW52YXMuY29udGVudERvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5jb250ZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoZSkgPT4gcmVzb2x2ZSgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignaWZyYW1lIGNhbiBub3QgYmUgbG9hZGVkJylcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJFbGVtZW50cyhjYW52YXMuY29udGVudFdpbmRvdylcbiAgICByZXR1cm4gY2FsbGJhY2soY2FudmFzLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsIHNlbGVjdG9yKTtcbn1cblxuXG5cblxuXG5cblxuLy8gYXR0cmlidXRlcy5wcm90b3R5cGUuZ2V0SW5wdXRzID0gZnVuY3Rpb24gZ2V0SW5wdXRzKGVsZW1lbnQpIHtcbi8vICAgICBsZXQgaW5wdXRzID0gW107XG4vLyAgICAgbGV0IGFsbElucHV0cyA9IEFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKSk7XG4vLyAgICAgYWxsSW5wdXRzLmZvckVhY2goKGlucHV0Q2FuZGlkYXRlKSA9PiB7XG4vLyAgICAgICAgIGxldCBpbnB1dE1ldGEgPSBnZXRJbnB1dE1ldGFEYXRhKGlucHV0Q2FuZGlkYXRlKTtcbi8vICAgICAgICAgaWYgKCFpbnB1dE1ldGEpIHJldHVybjtcblxuLy8gICAgICAgICBsZXQgYWxsUmVmZXJlbmNlZEVsID0gYWxsRnJhbWUoKGZyYW1lKSA9PlxuLy8gICAgICAgICAgICAgZnJhbWUucXVlcnlTZWxlY3RvckFsbChcbi8vICAgICAgICAgICAgICAgICBpbnB1dE1ldGEuaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1hdHRyaWJ1dGVzX3RhcmdldFwiKVxuLy8gICAgICAgICAgICAgKVxuLy8gICAgICAgICApO1xuLy8gICAgICAgICBpZiAoQXJyYXkuZnJvbShhbGxSZWZlcmVuY2VkRWwpLmluY2x1ZGVzKGVsZW1lbnQpKSB7XG4vLyAgICAgICAgICAgICBpbnB1dHMucHVzaChpbnB1dE1ldGEuaW5wdXQpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfSk7XG4vLyAgICAgcmV0dXJuIGlucHV0cztcbi8vIH1cbi8vYXR0cmlidXRlcy5wcm90b3R5cGUucGVySW5wdXQgPSAgYXN5bmMgZnVuY3Rpb24gcGVySW5wdXQoaW5wdXQsIGNhbGxiYWNrKSB7XG4vLyAgICAgbGV0IGlucHV0TWV0YSwgZWxlbWVudCwgZ3JvdXAgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWF0dHJpYnV0ZXNfZ3JvdXBcIik7XG4vLyAgICAgaWYgKGdyb3VwKSB7XG4vLyAgICAgICAgIFtpbnB1dE1ldGEsIGVsZW1lbnRdID0gZ2V0SW5wdXRzTWV0YURhdGEoaW5wdXQpO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIGlucHV0TWV0YSA9IHZhbGlkYXRlSW5wdXQoaW5wdXQpO1xuLy8gICAgICAgICBlbGVtZW50ID0gYXdhaXQgZ2V0RWxlbWVudEZyb21JbnB1dChpbnB1dCk7XG4vLyAgICAgfVxuXG4vLyAgICAgaWYgKCFpbnB1dE1ldGEgfHwgIWVsZW1lbnQpIHJldHVybjtcblxuLy8gICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0TWV0YSkpXG4vLyAgICAgICAgIGlucHV0TWV0YS5mb3JFYWNoKGFzeW5jKG1ldGFzKSA9PiBjYWxsYmFjayhtZXRhcywgZWxlbWVudCkpXG4vLyAgICAgZWxzZVxuLy8gICAgICAgICBjYWxsYmFjayhpbnB1dE1ldGEsIGVsZW1lbnQpXG4vLyB9XG5cbi8vYXR0cmlidXRlcy5wcm90b3R5cGUuZ2V0SW5wdXRzTWV0YURhdGEgPSAgZnVuY3Rpb24gZ2V0SW5wdXRzTWV0YURhdGEoaW5wdXQpIHtcbi8vICAgICBsZXQgbGlzdCA9IFtdLFxuLy8gICAgICAgICBpbnB1dHMgPSBbXTtcbi8vICAgICBsZXQgZWxlbWVudCA9IGdldEVsZW1lbnRGcm9tSW5wdXQoaW5wdXQpXG4vLyAgICAgbGV0IHJlYWxJbnB1dHMgPSBpbnB1dC5xdWVyeVNlbGVjdG9yQWxsKGdyb3VwKTtcbi8vICAgICByZWFsSW5wdXRzLmZvckVhY2goaW5wID0+IHtcbi8vICAgICAgICAgLy90b2RvOiBncm91cCBpcyBzdGF0aWMgXG4vLyAgICAgICAgIGlucHV0cy5wdXNoKGlucClcbi8vICAgICAgICAgbGlzdC5wdXNoKHZhbGlkYXRlSW5wdXQoaW5wKSlcbi8vICAgICB9KVxuLy8gICAgIGdyb3VwRWwuc2V0KGlucHV0LCBpbnB1dHMpO1xuLy8gICAgIHJldHVybiBbbGlzdCwgZWxlbWVudF07XG4vLyB9XG5cblxuXG4vLyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbi8vICAgICBsZXQgYXR0cmlidXRlID0gbmV3IGF0dHJpYnV0ZXMoeyBkb2N1bWVudCwgZXhjbHVkZTogJyNnaG9zdEVmZmVjdCwudmRvbS1pdGVtICcgfSlcbi8vICAgICBhdHRyaWJ1dGUuaW5pdCgpXG4vLyB9KVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdDogKHBhcmFtcykgPT4ge1xuICAgICAgICBsZXQgcyA9IG5ldyBhdHRyaWJ1dGVzKHBhcmFtcylcbiAgICAgICAgcy5pbml0KCk7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../CoCreate-components/CoCreate-attributes/src/CoCreate-attributes.js\n");

/***/ }),

/***/ "../CoCreate-components/CoCreate-attributes/src/common.js":
/*!****************************************************************!*\
  !*** ../CoCreate-components/CoCreate-attributes/src/common.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseClassRules = parseClassRules;\nexports.getCoCreateStyle = getCoCreateStyle;\nexports.setStyleClassIfDif = setStyleClassIfDif;\nexports.setAttributeIfDif = setAttributeIfDif;\nexports.setStyleIfDif = setStyleIfDif;\nexports.removeAllSelectedOptions = removeAllSelectedOptions;\nexports.renderOptions = renderOptions;\nexports.parseCssRules = parseCssRules;\nexports.rgba2hex = rgba2hex;\nexports.parseUnit = parseUnit;\nexports.toCamelCase = toCamelCase;\nexports.elStore = elStore;\n\n/*global CoCreate*/\nfunction parseClassRules(str) {\n  return str.split(' ').filter(cln => cln);\n}\n\nfunction getCoCreateStyle(classList) {\n  let styles = {};\n  classList.forEach(classname => {\n    let [name, value] = classname.split(\":\");\n    styles[toCamelCase(name)] = value;\n  });\n  return styles;\n}\n\nfunction setStyleClassIfDif(element, {\n  property,\n  camelProperty,\n  value,\n  computedStyles\n}) {\n  let classList = element.classList;\n  let styleList = new Map();\n  classList.forEach(classname => {\n    let [name, value] = classname.split(\":\");\n    value && styleList.set(name, value);\n  });\n  let elValue = styleList.get(property);\n\n  if (value) {\n    if (elValue) {\n      if (elValue != value) return classList.replace(`${property}:${elValue}`, `${property}:${value}`);\n    } else if (computedStyles[camelProperty] != value && !classList.has(`${property}:${value}`)) {\n      classList.add(`${property}:${value}`);\n      return true;\n    }\n  } else {\n    if (classList.contains(`${property}:${elValue}`)) {\n      classList.remove(`${property}:${elValue}`);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction setAttributeIfDif(property, value) {\n  if (this.getAttribute(property) !== value) {\n    if (value) this.setAttribute(property, value);else this.removeAttribute(property);\n    return true;\n  }\n\n  return false;\n}\n\nfunction setStyleIfDif({\n  property,\n  camelProperty,\n  value,\n  computedStyles\n}) {\n  if (computedStyles[camelProperty] && computedStyles[camelProperty] !== value) {\n    this.style[property] = value;\n    return true;\n  } else return false;\n} // CoCreate Select helper\n// export function getAllSelectedOptions() {\n//     let options = this.querySelectorAll(\":scope > [selected]\");\n//     return Array.from(options).map((o) => o.getAttribute(\"value\"));\n// };\n\n\nfunction removeAllSelectedOptions() {\n  let options = this.querySelectorAll(\":scope > [selected]\");\n  return Array.from(options).forEach(o => o.remove());\n}\n\n; // export function getAllOptions() {\n//     let options = this.querySelectorAll(\":scope > ul > [value]\");\n//     return Array.from(options).map((o) => o.getAttribute(\"value\"));\n// };\n\nfunction renderOptions(input, arrValue) {\n  if (arrValue && arrValue.length) CoCreate.select.renderValue(input, arrValue);else removeAllSelectedOptions.call(input);\n} // CoCreate Select helper end  \n\n\nfunction parseCssRules(str) {\n  let styleObject = {};\n  if (str.split) str.split(\";\").forEach(rule => {\n    let ruleSplit = rule.split(\":\");\n    let key = ruleSplit.shift().trim();\n    let value = ruleSplit.join().trim();\n    if (key) styleObject[key] = value;\n  });\n  return styleObject;\n}\n\nfunction rgba2hex(orig) {\n  let a,\n      isPercent,\n      rgb = orig.replace(/\\s/g, '').match(/^rgba?\\((\\d+),(\\d+),(\\d+),?([^,\\s)]+)?/i),\n      alpha = (rgb && rgb[4] || \"\").trim(),\n      hex = rgb ? (rgb[1] | 1 << 8).toString(16).slice(1) + (rgb[2] | 1 << 8).toString(16).slice(1) + (rgb[3] | 1 << 8).toString(16).slice(1) : orig;\n\n  if (alpha !== \"\") {\n    a = alpha;\n  } else {\n    a = 1;\n  } // multiply before convert to HEX\n\n\n  a = (a * 255 | 1 << 8).toString(16).slice(1);\n  hex = hex + a;\n  return hex;\n}\n\nfunction parseUnit(style) {\n  let value = parseFloat(style);\n  if (isNaN(value)) return [style, ''];else {\n    let valueLength = (value + \"\").length;\n    return [value, style.substr(valueLength)];\n  }\n}\n\nfunction toCamelCase(str) {\n  let index = 0;\n\n  do {\n    index = str.indexOf(\"-\", index);\n\n    if (index !== -1) {\n      let t = str.substring(0, index);\n      t += String.fromCharCode(str.charCodeAt(index + 1) - 32);\n      t += str.substr(index + 2);\n      str = t;\n    } else break;\n  } while (true);\n\n  return str;\n} // export function setCCStyle({ property, camelProperty, value, computedStyles }) {\n//     let hasChanged = false;\n//     if (computedStyles[camelProperty]  && computedStyles[camelProperty] !== value) {\n//         for (let classname of this.classList) {\n//             let [name, styleValue] = classname.split(\":\");\n//             if (name === property && styleValue) {\n//                 if (value)\n//                     this.classList.replace(classname, property + \":\" + value);\n//                 else\n//                     this.classList.remove(classname)\n//                 hasChanged = true;\n//                 break;\n//             }\n//         }\n//         if (!hasChanged)\n//             this.classList.add(property + \":\" + value);\n//         return true;\n//     } else\n//         return false;\n// }\n\n\nfunction elStore() {\n  this.cache = new Map();\n\n  this.spread = function set(key, object) {\n    this.cache.set(key, { ...this.cache.get(key),\n      ...object\n    });\n  };\n\n  this.set = function set(key, property, value) {\n    this.cache.set(key, { ...this.cache.get(key),\n      [property]: value\n    });\n  };\n\n  this.get = function get(key, property) {\n    let value = this.cache.get(key);\n    return value ? value[property] : undefined;\n  };\n\n  this.reset = function reset(key) {\n    this.cache.delete(key);\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5hdHRyaWJ1dGVzLy4uL0NvQ3JlYXRlLWNvbXBvbmVudHMvQ29DcmVhdGUtYXR0cmlidXRlcy9zcmMvY29tbW9uLmpzPzU0NGIiXSwibmFtZXMiOlsicGFyc2VDbGFzc1J1bGVzIiwic3RyIiwic3BsaXQiLCJmaWx0ZXIiLCJjbG4iLCJnZXRDb0NyZWF0ZVN0eWxlIiwiY2xhc3NMaXN0Iiwic3R5bGVzIiwiZm9yRWFjaCIsImNsYXNzbmFtZSIsIm5hbWUiLCJ2YWx1ZSIsInRvQ2FtZWxDYXNlIiwic2V0U3R5bGVDbGFzc0lmRGlmIiwiZWxlbWVudCIsInByb3BlcnR5IiwiY2FtZWxQcm9wZXJ0eSIsImNvbXB1dGVkU3R5bGVzIiwic3R5bGVMaXN0IiwiTWFwIiwic2V0IiwiZWxWYWx1ZSIsImdldCIsInJlcGxhY2UiLCJoYXMiLCJhZGQiLCJjb250YWlucyIsInJlbW92ZSIsInNldEF0dHJpYnV0ZUlmRGlmIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0U3R5bGVJZkRpZiIsInN0eWxlIiwicmVtb3ZlQWxsU2VsZWN0ZWRPcHRpb25zIiwib3B0aW9ucyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJBcnJheSIsImZyb20iLCJvIiwicmVuZGVyT3B0aW9ucyIsImlucHV0IiwiYXJyVmFsdWUiLCJsZW5ndGgiLCJDb0NyZWF0ZSIsInNlbGVjdCIsInJlbmRlclZhbHVlIiwiY2FsbCIsInBhcnNlQ3NzUnVsZXMiLCJzdHlsZU9iamVjdCIsInJ1bGUiLCJydWxlU3BsaXQiLCJrZXkiLCJzaGlmdCIsInRyaW0iLCJqb2luIiwicmdiYTJoZXgiLCJvcmlnIiwiYSIsImlzUGVyY2VudCIsInJnYiIsIm1hdGNoIiwiYWxwaGEiLCJoZXgiLCJ0b1N0cmluZyIsInNsaWNlIiwicGFyc2VVbml0IiwicGFyc2VGbG9hdCIsImlzTmFOIiwidmFsdWVMZW5ndGgiLCJzdWJzdHIiLCJpbmRleCIsImluZGV4T2YiLCJ0Iiwic3Vic3RyaW5nIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImVsU3RvcmUiLCJjYWNoZSIsInNwcmVhZCIsIm9iamVjdCIsInVuZGVmaW5lZCIsInJlc2V0IiwiZGVsZXRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVPLFNBQVNBLGVBQVQsQ0FBeUJDLEdBQXpCLEVBQThCO0FBQ2pDLFNBQU9BLEdBQUcsQ0FBQ0MsS0FBSixDQUFVLEdBQVYsRUFBZUMsTUFBZixDQUFzQkMsR0FBRyxJQUFJQSxHQUE3QixDQUFQO0FBRUg7O0FBRU0sU0FBU0MsZ0JBQVQsQ0FBMEJDLFNBQTFCLEVBQXFDO0FBQ3hDLE1BQUlDLE1BQU0sR0FBRyxFQUFiO0FBQ0FELFdBQVMsQ0FBQ0UsT0FBVixDQUFtQkMsU0FBRCxJQUFlO0FBQzdCLFFBQUksQ0FBQ0MsSUFBRCxFQUFPQyxLQUFQLElBQWdCRixTQUFTLENBQUNQLEtBQVYsQ0FBZ0IsR0FBaEIsQ0FBcEI7QUFDQUssVUFBTSxDQUFDSyxXQUFXLENBQUNGLElBQUQsQ0FBWixDQUFOLEdBQTRCQyxLQUE1QjtBQUNILEdBSEQ7QUFLQSxTQUFPSixNQUFQO0FBQ0g7O0FBS00sU0FBU00sa0JBQVQsQ0FBNEJDLE9BQTVCLEVBQXFDO0FBQUVDLFVBQUY7QUFBWUMsZUFBWjtBQUEyQkwsT0FBM0I7QUFBa0NNO0FBQWxDLENBQXJDLEVBQXlGO0FBQzVGLE1BQUlYLFNBQVMsR0FBR1EsT0FBTyxDQUFDUixTQUF4QjtBQUNBLE1BQUlZLFNBQVMsR0FBRyxJQUFJQyxHQUFKLEVBQWhCO0FBQ0FiLFdBQVMsQ0FBQ0UsT0FBVixDQUFtQkMsU0FBRCxJQUFlO0FBQzdCLFFBQUksQ0FBQ0MsSUFBRCxFQUFPQyxLQUFQLElBQWdCRixTQUFTLENBQUNQLEtBQVYsQ0FBZ0IsR0FBaEIsQ0FBcEI7QUFDQVMsU0FBSyxJQUFJTyxTQUFTLENBQUNFLEdBQVYsQ0FBY1YsSUFBZCxFQUFvQkMsS0FBcEIsQ0FBVDtBQUNILEdB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QjtBQUNILEdBRkQ7QUFHSCIsImZpbGUiOiIuLi9Db0NyZWF0ZS1jb21wb25lbnRzL0NvQ3JlYXRlLWF0dHJpYnV0ZXMvc3JjL2NvbW1vbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIENvQ3JlYXRlKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2xhc3NSdWxlcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcgJykuZmlsdGVyKGNsbiA9PiBjbG4pO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb0NyZWF0ZVN0eWxlKGNsYXNzTGlzdCkge1xuICAgIGxldCBzdHlsZXMgPSB7fTtcbiAgICBjbGFzc0xpc3QuZm9yRWFjaCgoY2xhc3NuYW1lKSA9PiB7XG4gICAgICAgIGxldCBbbmFtZSwgdmFsdWVdID0gY2xhc3NuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgc3R5bGVzW3RvQ2FtZWxDYXNlKG5hbWUpXSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0eWxlcztcbn1cblxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFN0eWxlQ2xhc3NJZkRpZihlbGVtZW50LCB7IHByb3BlcnR5LCBjYW1lbFByb3BlcnR5LCB2YWx1ZSwgY29tcHV0ZWRTdHlsZXMgfSkge1xuICAgIGxldCBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgICBsZXQgc3R5bGVMaXN0ID0gbmV3IE1hcCgpO1xuICAgIGNsYXNzTGlzdC5mb3JFYWNoKChjbGFzc25hbWUpID0+IHtcbiAgICAgICAgbGV0IFtuYW1lLCB2YWx1ZV0gPSBjbGFzc25hbWUuc3BsaXQoXCI6XCIpO1xuICAgICAgICB2YWx1ZSAmJiBzdHlsZUxpc3Quc2V0KG5hbWUsIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIGxldCBlbFZhbHVlID0gc3R5bGVMaXN0LmdldChwcm9wZXJ0eSk7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGVsVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlbFZhbHVlICE9IHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc0xpc3QucmVwbGFjZShgJHtwcm9wZXJ0eX06JHtlbFZhbHVlfWAsIGAke3Byb3BlcnR5fToke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXB1dGVkU3R5bGVzW2NhbWVsUHJvcGVydHldICE9IHZhbHVlICYmICFjbGFzc0xpc3QuaGFzKGAke3Byb3BlcnR5fToke3ZhbHVlfWApKVxuICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKGAke3Byb3BlcnR5fToke3ZhbHVlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGNsYXNzTGlzdC5jb250YWlucyhgJHtwcm9wZXJ0eX06JHtlbFZhbHVlfWApKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKGAke3Byb3BlcnR5fToke2VsVmFsdWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZUlmRGlmKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZShwcm9wZXJ0eSkgIT09IHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0U3R5bGVJZkRpZih7IHByb3BlcnR5LCBjYW1lbFByb3BlcnR5LCB2YWx1ZSwgY29tcHV0ZWRTdHlsZXMgfSkge1xuICAgIGlmIChjb21wdXRlZFN0eWxlc1tjYW1lbFByb3BlcnR5XSAmJiBjb21wdXRlZFN0eWxlc1tjYW1lbFByb3BlcnR5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIENvQ3JlYXRlIFNlbGVjdCBoZWxwZXJcbi8vIGV4cG9ydCBmdW5jdGlvbiBnZXRBbGxTZWxlY3RlZE9wdGlvbnMoKSB7XG4vLyAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiBbc2VsZWN0ZWRdXCIpO1xuLy8gICAgIHJldHVybiBBcnJheS5mcm9tKG9wdGlvbnMpLm1hcCgobykgPT4gby5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSk7XG4vLyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsU2VsZWN0ZWRPcHRpb25zKCkge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gW3NlbGVjdGVkXVwiKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvcHRpb25zKS5mb3JFYWNoKChvKSA9PiBvLnJlbW92ZSgpKTtcbn07XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBnZXRBbGxPcHRpb25zKCkge1xuLy8gICAgIGxldCBvcHRpb25zID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gdWwgPiBbdmFsdWVdXCIpO1xuLy8gICAgIHJldHVybiBBcnJheS5mcm9tKG9wdGlvbnMpLm1hcCgobykgPT4gby5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSk7XG4vLyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyT3B0aW9ucyhpbnB1dCwgYXJyVmFsdWUpIHtcbiAgICBpZiAoYXJyVmFsdWUgJiYgYXJyVmFsdWUubGVuZ3RoKVxuICAgICAgICBDb0NyZWF0ZS5zZWxlY3QucmVuZGVyVmFsdWUoaW5wdXQsIGFyclZhbHVlKVxuICAgIGVsc2VcbiAgICAgICAgcmVtb3ZlQWxsU2VsZWN0ZWRPcHRpb25zLmNhbGwoaW5wdXQpXG59XG4vLyBDb0NyZWF0ZSBTZWxlY3QgaGVscGVyIGVuZCAgXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDc3NSdWxlcyhzdHIpIHtcbiAgICBsZXQgc3R5bGVPYmplY3QgPSB7fTtcbiAgICBpZiAoc3RyLnNwbGl0KVxuICAgICAgICBzdHIuc3BsaXQoXCI7XCIpLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICAgICAgICAgIGxldCBydWxlU3BsaXQgPSBydWxlLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIGxldCBrZXkgPSBydWxlU3BsaXQuc2hpZnQoKS50cmltKCk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBydWxlU3BsaXQuam9pbigpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChrZXkpIHN0eWxlT2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gcmdiYTJoZXgob3JpZykge1xuICAgIGxldCBhLCBpc1BlcmNlbnQsXG4gICAgICAgIHJnYiA9IG9yaWcucmVwbGFjZSgvXFxzL2csICcnKS5tYXRjaCgvXnJnYmE/XFwoKFxcZCspLChcXGQrKSwoXFxkKyksPyhbXixcXHMpXSspPy9pKSxcbiAgICAgICAgYWxwaGEgPSAocmdiICYmIHJnYls0XSB8fCBcIlwiKS50cmltKCksXG4gICAgICAgIGhleCA9IHJnYiA/XG4gICAgICAgIChyZ2JbMV0gfCAxIDw8IDgpLnRvU3RyaW5nKDE2KS5zbGljZSgxKSArXG4gICAgICAgIChyZ2JbMl0gfCAxIDw8IDgpLnRvU3RyaW5nKDE2KS5zbGljZSgxKSArXG4gICAgICAgIChyZ2JbM10gfCAxIDw8IDgpLnRvU3RyaW5nKDE2KS5zbGljZSgxKSA6IG9yaWc7XG5cbiAgICBpZiAoYWxwaGEgIT09IFwiXCIpIHtcbiAgICAgICAgYSA9IGFscGhhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYSA9IDE7XG4gICAgfVxuICAgIC8vIG11bHRpcGx5IGJlZm9yZSBjb252ZXJ0IHRvIEhFWFxuICAgIGEgPSAoKGEgKiAyNTUpIHwgMSA8PCA4KS50b1N0cmluZygxNikuc2xpY2UoMSlcbiAgICBoZXggPSBoZXggKyBhO1xuXG4gICAgcmV0dXJuIGhleDtcbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVuaXQoc3R5bGUpIHtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlKTtcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxuICAgICAgICByZXR1cm4gW3N0eWxlLCAnJ11cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gKHZhbHVlICsgXCJcIikubGVuZ3RoO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCBzdHlsZS5zdWJzdHIodmFsdWVMZW5ndGgpXTtcblxuICAgIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdG9DYW1lbENhc2Uoc3RyKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGluZGV4ID0gc3RyLmluZGV4T2YoXCItXCIsIGluZGV4KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IHQgPSBzdHIuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzdHIuY2hhckNvZGVBdChpbmRleCArIDEpIC0gMzIpO1xuICAgICAgICAgICAgdCArPSBzdHIuc3Vic3RyKGluZGV4ICsgMik7XG4gICAgICAgICAgICBzdHIgPSB0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYnJlYWs7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIHNldENDU3R5bGUoeyBwcm9wZXJ0eSwgY2FtZWxQcm9wZXJ0eSwgdmFsdWUsIGNvbXB1dGVkU3R5bGVzIH0pIHtcbi8vICAgICBsZXQgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuLy8gICAgIGlmIChjb21wdXRlZFN0eWxlc1tjYW1lbFByb3BlcnR5XSAgJiYgY29tcHV0ZWRTdHlsZXNbY2FtZWxQcm9wZXJ0eV0gIT09IHZhbHVlKSB7XG4vLyAgICAgICAgIGZvciAobGV0IGNsYXNzbmFtZSBvZiB0aGlzLmNsYXNzTGlzdCkge1xuLy8gICAgICAgICAgICAgbGV0IFtuYW1lLCBzdHlsZVZhbHVlXSA9IGNsYXNzbmFtZS5zcGxpdChcIjpcIik7XG4vLyAgICAgICAgICAgICBpZiAobmFtZSA9PT0gcHJvcGVydHkgJiYgc3R5bGVWYWx1ZSkge1xuLy8gICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcbi8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVwbGFjZShjbGFzc25hbWUsIHByb3BlcnR5ICsgXCI6XCIgKyB2YWx1ZSk7XG4vLyAgICAgICAgICAgICAgICAgZWxzZVxuLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NuYW1lKVxuLy8gICAgICAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuLy8gICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyAgICAgICAgIGlmICghaGFzQ2hhbmdlZClcbi8vICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZChwcm9wZXJ0eSArIFwiOlwiICsgdmFsdWUpO1xuLy8gICAgICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgICB9IGVsc2Vcbi8vICAgICAgICAgcmV0dXJuIGZhbHNlO1xuLy8gfVxuXG5cblxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gZWxTdG9yZSgpIHtcbiAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3ByZWFkID0gZnVuY3Rpb24gc2V0KGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgeyAuLi50aGlzLmNhY2hlLmdldChrZXkpLCAuLi5vYmplY3QgfSlcbiAgICB9XG4gICAgdGhpcy5zZXQgPSBmdW5jdGlvbiBzZXQoa2V5LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB7IC4uLnRoaXMuY2FjaGUuZ2V0KGtleSksIFtwcm9wZXJ0eV06IHZhbHVlIH0pXG4gICAgfVxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSwgcHJvcGVydHkpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5jYWNoZS5nZXQoa2V5KVxuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZVtwcm9wZXJ0eV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiByZXNldChrZXkpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KVxuICAgIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../CoCreate-components/CoCreate-attributes/src/common.js\n");

/***/ })

/******/ })["default"];
});