/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CoCreateAttributes"] = factory();
	else
		root["CoCreateAttributes"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/CoCreate-attributes.js":
/*!************************************!*\
  !*** ./src/CoCreate-attributes.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * refactor:\n * refactor mutation observer to a component\n * refactor cc_select_utility, allFrame, parseCssRules, parseClassList to a global/general workspace\n */\n//store all frames\nvar filters = [];\nvar allFrames = new Map();\nvar tools = {};\nvar CoCreateAttribute = {\n  init: init,\n  addFilter: addFilter\n}; // first time load\n\nwindow.addEventListener(\"load\", function () {\n  init({\n    windowObject: window,\n    docObject: document\n  });\n  window.CoCreateObserver.add({\n    observe: [\"attributes\", \"characterData\"],\n    task: function task(mutation) {\n      return triggerElementMutation(mutation);\n    }\n  });\n  window.CoCreateObserver.add({\n    name: \"ccAttribute\",\n    observe: [\"attributes\"],\n    attributes: [\"data-attribute_target\"],\n    task: function task(mutation) {\n      return updateInput(mutation.target);\n    }\n  });\n  allFrame(function (frame) {\n    return frame.querySelectorAll(\"[data-attribute_target]\");\n  }).forEach(function (input) {\n    return updateInput(input);\n  });\n});\n\nfunction updateInput(input) {\n  var elSelectorId = input.getAttribute(\"data-attribute_target\");\n  if (!elSelectorId) return;\n  var element = allFrame(function (frame) {\n    return frame.querySelector(elSelectorId);\n  })[0];\n  var read = input.getAttribute(\"data-attribute_sync\");\n  if (element && element.getAttribute(read)) fromInput(input, function (type, metadata) {\n    if (metadata && metadata[\"class\"] === \"toggle\") input.checked = fromElementToBoolean({\n      input: input,\n      element: element,\n      inputValue: input.getAttribute(\"value\"),\n      read: read\n    });else if (input.tagName == \"SELECT\") {\n      fromElementToSelect({\n        input: input,\n        element: element,\n        read: read\n      });\n    } else if (input.tagName == \"COCREATE-SELECT\") {\n      fromElementToCCSelect({\n        input: input,\n        element: element,\n        read: read\n      });\n    } else {\n      input.lastValue = input.value;\n      input.value = fromElementToText({\n        element: element,\n        read: read\n      }); // todo: up or bottom is correct which one?\n      //input.value = fromElementToText({ element, read });\n    }\n  });\n}\n\nfunction parseCssRules(str) {\n  var styleObject = {};\n  if (str.split) str.split(\";\").forEach(function (rule) {\n    var ruleSplit = rule.split(\":\");\n    var key = ruleSplit.shift().trim();\n    var value = ruleSplit.join().trim();\n    if (key) styleObject[key] = value;\n  });\n  return styleObject;\n}\n\nfunction parseCssRulesAsArray(str) {\n  if (str.split) return str.split(\";\").slice(0, -1).map(function (st) {\n    return st.trim();\n  });\n  return [];\n}\n\nfunction allFrame(callback) {\n  var result = new Set();\n\n  var _iterator = _createForOfIteratorHelper(allFrames),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          frameObject = _step$value[0],\n          frame = _step$value[1];\n\n      var callbackResult = callback(frame.document, frame.window);\n      if (callbackResult && typeof callbackResult[Symbol.iterator] === \"function\") callbackResult.forEach(function (el) {\n        return result.add(el);\n      });else if (callbackResult) result.add(callbackResult);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return Array.from(result).filter(function (el) {\n    return !filters.some(function (filter) {\n      return el.matches(filter);\n    });\n  });\n}\n\nfunction init(_ref) {\n  var windowObject = _ref.windowObject,\n      docObject = _ref.docObject,\n      isIframe = _ref.isIframe,\n      frame = _ref.frame,\n      _ref$onCollaboration = _ref.onCollaboration,\n      onCollaboration = _ref$onCollaboration === void 0 ? function () {} : _ref$onCollaboration;\n  var ref;\n  tools.onCollaboration = onCollaboration;\n\n  if (isIframe) {\n    var frameWindow = frame.contentWindow;\n    var frameDocument = frameWindow.document || frame.contentDocument;\n    ref = {\n      frame: frame,\n      window: frameWindow,\n      document: frameDocument,\n      isIframe: true\n    };\n    allFrames.set(frame, ref);\n  } else {\n    ref = {\n      window: windowObject,\n      document: docObject,\n      isIframe: false\n    };\n    allFrames.set(\"main\", ref);\n  }\n\n  ref.window.addEventListener(\"load\", function () {\n    ref.window.CoCreateObserver.add({\n      observe: [\"attributes\", \"characterData\"],\n      task: function task(mutation) {\n        return triggerElementMutation(mutation);\n      }\n    });\n    ref.window.CoCreateObserver.add({\n      name: \"ccAttribute\",\n      observe: [\"attributes\"],\n      attributes: [\"data-attribute_target\"],\n      task: function task(mutation) {\n        return updateInput(mutation.target);\n      }\n    });\n  });\n\n  ref.window.HTMLElement.prototype.getAllSelectedOptions = function getAllSelectedOptions() {\n    var options = this.querySelectorAll(\":scope > [selected]\");\n    return Array.from(options).map(function (o) {\n      return o.getAttribute(\"value\");\n    });\n  };\n\n  ref.window.HTMLElement.prototype.getAllOptions = function getAllOptions() {\n    var options = this.querySelectorAll(\":scope > ul > [value]\");\n    return Array.from(options).map(function (o) {\n      return o.getAttribute(\"value\");\n    });\n  };\n\n  ref.document.addEventListener(\"input\", function (e) {\n    var input = e.target;\n    var elSelectorId = input.getAttribute(\"data-attribute_target\");\n    if (!elSelectorId) return;\n    var elements = allFrame(function (document) {\n      return document.querySelector(elSelectorId);\n    });\n    var read = e.target.getAttribute(\"data-attribute_sync\");\n    elements.forEach(function (element) {\n      fromInput(input, function (type, metadata) {\n        if (metadata && metadata.type === \"checkbox\") {\n          var status = input[metadata.read];\n          if (status) __addToElement(input, element, type, read);else __removeToElement(input, element, type, read);\n        } else if (metadata && metadata.type === \"radio\") {\n          __addToElement(input, element, type, read);\n\n          var inputs = allFrame(function (frame) {\n            return frame.getElementsByName(input.name);\n          });\n          inputs = Array.from(inputs);\n          var ourInputIndex = inputs.indexOf(input);\n          if (ourInputIndex !== -1) delete inputs[ourInputIndex];\n          inputs.forEach(function (input) {\n            if (input) __removeToElement(input, element, type, read);\n          });\n        } else if (metadata && metadata.type === \"select\") {\n          var selectedOptions = getSelectOptions(input, true);\n          var unSelectedOptions = getSelectOptions(input, false);\n\n          __addToElement(input, element, selectedOptions, read);\n\n          __removeToElement(input, element, unSelectedOptions, read);\n        } else if (metadata && metadata.type === \"cocreate-select\") {\n          var selectedOptions2 = input.getAllSelectedOptions(); // let unSelectedOptions2 = input\n          //   .getAllOptions()\n          //   .filter((o) => !selectedOptions2.includes(o));\n\n          __addToElement(input, element, selectedOptions2, read); // __removeToElement(input, element, unSelectedOptions2, read);\n\n        } else {\n          __removeToElement(input, element, \"lastValue\", read);\n\n          __addToElement(input, element, type, read);\n        }\n      });\n    });\n  });\n} // if (input.tagName === \"COCREATE-SELECT\" && !input.selectOption) {\n//   for (let [k, v] of Object.entries(cocreateUtility)) {\n//     input[k] = v;\n//   }\n// }\n\n\nfunction addFilter(selector) {\n  filters.push(selector);\n} // inputs.forEach((input) => {\n//   //add cc_select_utility\n//   if (input.tagName === \"COCREATE-SELECT\") {\n//     for (let [k, v] of Object.entries(cocreateUtility)) {\n//       input[k] = v;\n//     }\n//   }\n//   inputAddEventListener(input)\n// });\n\n\nfunction triggerElementMutation(mutation) {\n  var element;\n  var attributeName;\n\n  switch (mutation.type) {\n    case \"attributes\":\n      attributeName = mutation.attributeName;\n      element = mutation.target;\n      break;\n\n    case \"characterData\":\n      attributeName = \"innerText\";\n      element = mutation.target.parentElement;\n      break;\n  }\n\n  if (!element || element && element.getAttribute(\"data-attribute_sync\")) return;\n  var connectedInput = allFrame(function (frame) {\n    return frame.querySelectorAll(\"[data-attribute_target]\");\n  }).filter(function (input) {\n    if (input.getAttribute(\"data-attribute_sync\") !== attributeName) return false;\n    var query = input.getAttribute(\"data-attribute_target\");\n    var elements = allFrame(function (frame) {\n      return frame.querySelectorAll(query);\n    });\n    return elements.includes(element);\n  });\n  connectedInput.forEach(function (input) {\n    var read = input.getAttribute(\"data-attribute_sync\");\n    if (read === attributeName) fromInput(input, function (type, metadata) {\n      if (metadata && metadata[\"class\"] === \"toggle\") input.checked = fromElementToBoolean({\n        input: input,\n        element: element,\n        inputValue: input.getAttribute(\"value\"),\n        read: read\n      });else if (input.tagName == \"SELECT\") {\n        fromElementToSelect({\n          input: input,\n          element: element,\n          read: read\n        });\n      } else if (input.tagName == \"COCREATE-SELECT\") {\n        fromElementToCCSelect({\n          input: input,\n          element: element,\n          read: read\n        });\n      } else {\n        var inputValue = fromElementToText({\n          element: element,\n          read: read\n        });\n        if (input.value.trim() == inputValue) return;\n        input.lastValue = input.value;\n        input.value = inputValue;\n      }\n    });\n  });\n}\n\nfunction parseClassList(str) {\n  if (str.split) return str.split(\" \").map(function (st) {\n    return st.trim();\n  });\n  return [];\n}\n\nfunction isSubset(obj1, obj2) {\n  for (var _i2 = 0, _Object$entries = Object.entries(obj2); _i2 < _Object$entries.length; _i2++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (obj1[key] !== value) return false;\n  }\n\n  return true;\n}\n\nfunction fromInput(input, callback) {\n  switch (input.tagName.toLowerCase()) {\n    case \"input\":\n      switch (input.type.toLowerCase()) {\n        case \"text\":\n        case \"color\":\n        case \"date\":\n          callback(\"value\");\n          break;\n\n        case \"checkbox\":\n          callback(\"value\", {\n            \"class\": \"toggle\",\n            type: \"checkbox\",\n            read: \"checked\"\n          });\n          break;\n\n        case \"radio\":\n          callback(\"value\", {\n            \"class\": \"toggle\",\n            type: \"radio\",\n            read: \"checked\"\n          });\n          break;\n\n        default:\n          callback(\"value\");\n      }\n\n      break;\n\n    case \"select\":\n      callback(\"value\", {\n        type: \"select\",\n        \"class\": input.multiple ? \"multiselect\" : \"select\"\n      });\n      break;\n\n    case \"textarea\":\n      callback(\"value\");\n      break;\n\n    case \"cocreate-select\":\n      callback(\"COCREATE-SELECT\", {\n        type: \"cocreate-select\",\n        \"class\": input.multiple ? \"multiselect\" : \"select\"\n      });\n      break;\n\n    default:\n      if (input.getAttribute(\"contenteditable\") !== null) callback(\"innerText\");else callback(\"value\");\n  }\n}\n\nfunction fromElementToBoolean(_ref2) {\n  var input = _ref2.input,\n      element = _ref2.element,\n      inputValue = _ref2.inputValue,\n      read = _ref2.read;\n\n  switch (read) {\n    case \"style\":\n      var parsedCss = parseCssRules(inputValue);\n      var elementStyle = element.style;\n      return isSubset(elementStyle, parsedCss);\n      break;\n\n    case \"class\":\n      var classList = parseClassList(inputValue);\n      var targetClassList = Array.from(element.classList);\n      return classList.every(function (className) {\n        return targetClassList.includes(className);\n      });\n      break;\n\n    default:\n      return element.getAttribute(read) ? true : false;\n  }\n}\n\nfunction fromElementToText(_ref3) {\n  var element = _ref3.element,\n      read = _ref3.read;\n\n  switch (read) {\n    case \"style\":\n      return element.getAttribute(read);\n      break;\n\n    case \"class\":\n      return element.classList.toString();\n      break;\n\n    case \"innerText\":\n      return element.innerText;\n      break;\n\n    default:\n      return element.getAttribute(read);\n  }\n}\n\nfunction __addToElement(input, element, type, read, values) {\n  if (!values) {\n    if (_typeof(type) === \"object\") values = type;else values = [input.getAttribute(type) || input[type]];\n    collaborate({\n      method: \"add\",\n      values: values,\n      element: element,\n      type: type,\n      read: read\n    });\n  }\n\n  values.forEach(function (value) {\n    switch (read) {\n      case \"style\":\n        if (!value) return;\n        var parsedCss = parseCssRules(value);\n        Object.assign(element.style, parsedCss);\n        break;\n\n      case \"class\":\n        // value\n        //   .split(\" \")\n        //   .forEach((classname) => element.classList.remove(classname));\n        if (!value) return;\n        value.split(\" \").forEach(function (classname) {\n          return classname && element.classList.add(classname);\n        });\n        break;\n\n      case \"innerText\":\n        element[read] = value;\n        triggerElementMutation({\n          type: \"characterData\",\n          target: {\n            parentElement: element\n          }\n        });\n        break;\n\n      default:\n        if (value) element.setAttribute(read, value);else element.removeAttribute(read);\n    }\n  });\n}\n\nfunction __removeToElement(input, element, type, read, values) {\n  if (!values) {\n    if (_typeof(type) === \"object\") values = type;else values = [input.getAttribute(type) || input[type]];\n    collaborate({\n      method: \"remove\",\n      values: values,\n      element: element,\n      type: type,\n      read: read\n    });\n  }\n\n  values.forEach(function (value) {\n    switch (read) {\n      case \"style\":\n        if (!value) return;\n        var parsedCss = parseCssRules(value);\n        Object.keys(parsedCss).forEach(function (key) {\n          if (parsedCss[key]) element.style[key] = \"\";\n        });\n        break;\n\n      case \"class\":\n        // value\n        //   .split(\" \")\n        //   .forEach((classname) => element.classList.remove(classname));\n        if (!value) return;\n        value.split(\" \").forEach(function (classname) {\n          return classname && element.classList.remove(classname);\n        });\n        break;\n\n      default: // element.removeAttribute(read);\n\n    }\n  });\n}\n\nfunction getSelectOptions(select, state) {\n  var options = Array.from(select.options);\n  return options.filter(function (o) {\n    return state === undefined ? true : o.selected == state;\n  }).map(function (o) {\n    return o.value;\n  });\n}\n\nfunction isObjectEqual(object1, object2) {\n  for (var _i3 = 0, _Object$entries2 = Object.entries(object1); _i3 < _Object$entries2.length; _i3++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),\n        key = _Object$entries2$_i[0],\n        value = _Object$entries2$_i[1];\n\n    if (object1[key] !== object2[key] || object1[key] === \"\") return false;\n  }\n\n  return true;\n}\n\nfunction fromElementToSelect(_ref4) {\n  var input = _ref4.input,\n      element = _ref4.element,\n      read = _ref4.read;\n\n  for (var i = 0, len = input.options.length; i < len; i++) {\n    switch (read) {\n      case \"style\":\n        var parsed = parseCssRules(input.options[i].value);\n        if (isObjectEqual(parsed, element.style)) input.options[i].selected = true;else input.options[i].selected = false; // if(unStyle.some(style => isObjectEqual(parsed, style)))\n\n        break;\n\n      case \"class\":\n        if (element.classList.contains(input.options[i].value)) input.options[i].selected = true;else input.options[i].selected = false;\n        break;\n\n      default:\n        if (element.getAttribute(read) == input.options[i].value) input.options[i].selected = true;else input.options[i].selected = false;\n    }\n  }\n}\n\nfunction fromElementToCCSelect(_ref5) {\n  var input = _ref5.input,\n      element = _ref5.element,\n      read = _ref5.read;\n  var options,\n      selOptions = [],\n      selOptions2;\n\n  switch (read) {\n    case \"style\":\n      // options = input.getAllOptions();\n      // for (let i = 0, len = options.length; i < len; i++) {\n      //   let parsed = parseCssRules(options[i]);\n      //   if (isObjectEqual(parsed, element.style))\n      //     selOptions.push( options[i] );\n      // }\n      // CoCreateSelect.renderValue(input, selOptions)\n      selOptions2 = parseCssRulesAsArray(element.getAttribute('style'));\n      CoCreateSelect.renderValue(input, selOptions2);\n      break;\n\n    case \"class\":\n      // options = input.getAllOptions();\n      // for (let i = 0, len = options.length; i < len; i++) {\n      //   if (element.classList.contains(options[i]))\n      //     selOptions.push( options[i] );\n      // }\n      // CoCreateSelect.renderValue(input, selOptions)\n      selOptions2 = parseClassList(element.getAttribute('class'));\n      CoCreateSelect.renderValue(input, selOptions2);\n      break;\n\n    default:\n      if (element.getAttribute(read)) CoCreateSelect.renderValue(input, element.getAttribute(read));\n    // todo: might break\n    // if (element.getAttribute(read) == options[i])\n    //   input.selectOption(options[i]);\n    // else input.unselectOption(options[i]);\n  }\n}\n\nCoCreateSocket.listen(\"ccAttribute\", function (_ref6) {\n  var method = _ref6.method,\n      values = _ref6.values,\n      element = _ref6.element,\n      type = _ref6.type,\n      read = _ref6.read;\n  element = allFrame(function (frame) {\n    return frame.querySelector(\"[data-element_id=\" + element + \"]\");\n  })[0];\n\n  if (method === \"add\") {\n    __addToElement(null, element, type, read, values);\n  } else if (method === \"remove\") {\n    __removeToElement(null, element, type, read, values);\n  }\n});\n\nfunction collaborate(data) {\n  tools.onCollaboration({\n    value: Array.isArray(data.values) ? data.values.join(' ') : data.values,\n    read: data.read,\n    element: data.element\n  });\n  CoCreate.sendMessage({\n    broadcast_sender: false,\n    rooms: \"\",\n    emit: {\n      message: \"ccAttribute\",\n      data: _objectSpread(_objectSpread({}, data), {}, {\n        element: data.element.getAttribute(\"data-element_id\")\n      })\n    }\n  });\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateAttribute);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZUF0dHJpYnV0ZXMvLi9zcmMvQ29DcmVhdGUtYXR0cmlidXRlcy5qcz82OWMxIl0sIm5hbWVzIjpbImZpbHRlcnMiLCJhbGxGcmFtZXMiLCJNYXAiLCJ0b29scyIsIkNvQ3JlYXRlQXR0cmlidXRlIiwiaW5pdCIsImFkZEZpbHRlciIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ3aW5kb3dPYmplY3QiLCJkb2NPYmplY3QiLCJkb2N1bWVudCIsIkNvQ3JlYXRlT2JzZXJ2ZXIiLCJhZGQiLCJvYnNlcnZlIiwidGFzayIsIm11dGF0aW9uIiwidHJpZ2dlckVsZW1lbnRNdXRhdGlvbiIsIm5hbWUiLCJhdHRyaWJ1dGVzIiwidXBkYXRlSW5wdXQiLCJ0YXJnZXQiLCJhbGxGcmFtZSIsImZyYW1lIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJpbnB1dCIsImVsU2VsZWN0b3JJZCIsImdldEF0dHJpYnV0ZSIsImVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwicmVhZCIsImZyb21JbnB1dCIsInR5cGUiLCJtZXRhZGF0YSIsImNoZWNrZWQiLCJmcm9tRWxlbWVudFRvQm9vbGVhbiIsImlucHV0VmFsdWUiLCJ0YWdOYW1lIiwiZnJvbUVsZW1lbnRUb1NlbGVjdCIsImZyb21FbGVtZW50VG9DQ1NlbGVjdCIsImxhc3RWYWx1ZSIsInZhbHVlIiwiZnJvbUVsZW1lbnRUb1RleHQiLCJwYXJzZUNzc1J1bGVzIiwic3RyIiwic3R5bGVPYmplY3QiLCJzcGxpdCIsInJ1bGUiLCJydWxlU3BsaXQiLCJrZXkiLCJzaGlmdCIsInRyaW0iLCJqb2luIiwicGFyc2VDc3NSdWxlc0FzQXJyYXkiLCJzbGljZSIsIm1hcCIsInN0IiwiY2FsbGJhY2siLCJyZXN1bHQiLCJTZXQiLCJmcmFtZU9iamVjdCIsImNhbGxiYWNrUmVzdWx0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJlbCIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsInNvbWUiLCJtYXRjaGVzIiwiaXNJZnJhbWUiLCJvbkNvbGxhYm9yYXRpb24iLCJyZWYiLCJmcmFtZVdpbmRvdyIsImNvbnRlbnRXaW5kb3ciLCJmcmFtZURvY3VtZW50IiwiY29udGVudERvY3VtZW50Iiwic2V0IiwiSFRNTEVsZW1lbnQiLCJwcm90b3R5cGUiLCJnZXRBbGxTZWxlY3RlZE9wdGlvbnMiLCJvcHRpb25zIiwibyIsImdldEFsbE9wdGlvbnMiLCJlIiwiZWxlbWVudHMiLCJzdGF0dXMiLCJfX2FkZFRvRWxlbWVudCIsIl9fcmVtb3ZlVG9FbGVtZW50IiwiaW5wdXRzIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJvdXJJbnB1dEluZGV4IiwiaW5kZXhPZiIsInNlbGVjdGVkT3B0aW9ucyIsImdldFNlbGVjdE9wdGlvbnMiLCJ1blNlbGVjdGVkT3B0aW9ucyIsInNlbGVjdGVkT3B0aW9uczIiLCJzZWxlY3RvciIsInB1c2giLCJhdHRyaWJ1dGVOYW1lIiwicGFyZW50RWxlbWVudCIsImNvbm5lY3RlZElucHV0IiwicXVlcnkiLCJpbmNsdWRlcyIsInBhcnNlQ2xhc3NMaXN0IiwiaXNTdWJzZXQiLCJvYmoxIiwib2JqMiIsIk9iamVjdCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsIm11bHRpcGxlIiwicGFyc2VkQ3NzIiwiZWxlbWVudFN0eWxlIiwic3R5bGUiLCJjbGFzc0xpc3QiLCJ0YXJnZXRDbGFzc0xpc3QiLCJldmVyeSIsImNsYXNzTmFtZSIsInRvU3RyaW5nIiwiaW5uZXJUZXh0IiwidmFsdWVzIiwiY29sbGFib3JhdGUiLCJtZXRob2QiLCJhc3NpZ24iLCJjbGFzc25hbWUiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJrZXlzIiwicmVtb3ZlIiwic2VsZWN0Iiwic3RhdGUiLCJ1bmRlZmluZWQiLCJzZWxlY3RlZCIsImlzT2JqZWN0RXF1YWwiLCJvYmplY3QxIiwib2JqZWN0MiIsImkiLCJsZW4iLCJsZW5ndGgiLCJwYXJzZWQiLCJjb250YWlucyIsInNlbE9wdGlvbnMiLCJzZWxPcHRpb25zMiIsIkNvQ3JlYXRlU2VsZWN0IiwicmVuZGVyVmFsdWUiLCJDb0NyZWF0ZVNvY2tldCIsImxpc3RlbiIsImRhdGEiLCJpc0FycmF5IiwiQ29DcmVhdGUiLCJzZW5kTWVzc2FnZSIsImJyb2FkY2FzdF9zZW5kZXIiLCJyb29tcyIsImVtaXQiLCJtZXNzYWdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUVBLElBQUlBLE9BQU8sR0FBRyxFQUFkO0FBQ0EsSUFBSUMsU0FBUyxHQUFHLElBQUlDLEdBQUosRUFBaEI7QUFDQSxJQUFJQyxLQUFLLEdBQUcsRUFBWjtBQUNBLElBQU1DLGlCQUFpQixHQUFHO0FBQUVDLE1BQUksRUFBSkEsSUFBRjtBQUFRQyxXQUFTLEVBQVRBO0FBQVIsQ0FBMUIsQyxDQUVBOztBQUNBQyxNQUFNLENBQUNDLGdCQUFQLENBQXdCLE1BQXhCLEVBQWdDLFlBQU07QUFDcENILE1BQUksQ0FBQztBQUFFSSxnQkFBWSxFQUFFRixNQUFoQjtBQUF3QkcsYUFBUyxFQUFFQztBQUFuQyxHQUFELENBQUo7QUFDQUosUUFBTSxDQUFDSyxnQkFBUCxDQUF3QkMsR0FBeEIsQ0FBNEI7QUFDMUJDLFdBQU8sRUFBRSxDQUFDLFlBQUQsRUFBZSxlQUFmLENBRGlCO0FBRTFCQyxRQUFJLEVBQUUsY0FBQ0MsUUFBRDtBQUFBLGFBQWNDLHNCQUFzQixDQUFDRCxRQUFELENBQXBDO0FBQUE7QUFGb0IsR0FBNUI7QUFLQVQsUUFBTSxDQUFDSyxnQkFBUCxDQUF3QkMsR0FBeEIsQ0FBNEI7QUFDMUJLLFFBQUksRUFBRSxhQURvQjtBQUUxQkosV0FBTyxFQUFFLENBQUMsWUFBRCxDQUZpQjtBQUcxQkssY0FBVSxFQUFFLENBQUMsdUJBQUQsQ0FIYztBQUkxQkosUUFBSSxFQUFFLGNBQUNDLFFBQUQ7QUFBQSxhQUFjSSxXQUFXLENBQUNKLFFBQVEsQ0FBQ0ssTUFBVixDQUF6QjtBQUFBO0FBSm9CLEdBQTVCO0FB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QUFDdEgsSUFGUztBQUdwQkYsV0FBTyxFQUFFd0gsSUFBSSxDQUFDeEg7QUFITSxHQUF0QjtBQU9BMEgsVUFBUSxDQUFDQyxXQUFULENBQXFCO0FBQ25CQyxvQkFBZ0IsRUFBRSxLQURDO0FBRW5CQyxTQUFLLEVBQUUsRUFGWTtBQUduQkMsUUFBSSxFQUFFO0FBQ0pDLGFBQU8sRUFBRSxhQURMO0FBRUpQLFVBQUksa0NBQ0NBLElBREQ7QUFFRnhILGVBQU8sRUFBRXdILElBQUksQ0FBQ3hILE9BQUwsQ0FBYUQsWUFBYixDQUEwQixpQkFBMUI7QUFGUDtBQUZBO0FBSGEsR0FBckI7QUFXRDs7QUFFRCxpRUFBZXhCLGlCQUFmIiwiZmlsZSI6Ii4vc3JjL0NvQ3JlYXRlLWF0dHJpYnV0ZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlZmFjdG9yOlxuICogcmVmYWN0b3IgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gYSBjb21wb25lbnRcbiAqIHJlZmFjdG9yIGNjX3NlbGVjdF91dGlsaXR5LCBhbGxGcmFtZSwgcGFyc2VDc3NSdWxlcywgcGFyc2VDbGFzc0xpc3QgdG8gYSBnbG9iYWwvZ2VuZXJhbCB3b3Jrc3BhY2VcbiAqL1xuXG5cbiAgLy9zdG9yZSBhbGwgZnJhbWVzXG5cbiAgbGV0IGZpbHRlcnMgPSBbXTtcbiAgbGV0IGFsbEZyYW1lcyA9IG5ldyBNYXAoKTtcbiAgbGV0IHRvb2xzID0ge307XG4gIGNvbnN0IENvQ3JlYXRlQXR0cmlidXRlID0geyBpbml0LCBhZGRGaWx0ZXIgfTtcblxuICAvLyBmaXJzdCB0aW1lIGxvYWRcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICBpbml0KHsgd2luZG93T2JqZWN0OiB3aW5kb3csIGRvY09iamVjdDogZG9jdW1lbnQgfSk7XG4gICAgd2luZG93LkNvQ3JlYXRlT2JzZXJ2ZXIuYWRkKHtcbiAgICAgIG9ic2VydmU6IFtcImF0dHJpYnV0ZXNcIiwgXCJjaGFyYWN0ZXJEYXRhXCJdLFxuICAgICAgdGFzazogKG11dGF0aW9uKSA9PiB0cmlnZ2VyRWxlbWVudE11dGF0aW9uKG11dGF0aW9uKSxcbiAgICB9KTtcblxuICAgIHdpbmRvdy5Db0NyZWF0ZU9ic2VydmVyLmFkZCh7XG4gICAgICBuYW1lOiBcImNjQXR0cmlidXRlXCIsXG4gICAgICBvYnNlcnZlOiBbXCJhdHRyaWJ1dGVzXCJdLFxuICAgICAgYXR0cmlidXRlczogW1wiZGF0YS1hdHRyaWJ1dGVfdGFyZ2V0XCJdLFxuICAgICAgdGFzazogKG11dGF0aW9uKSA9PiB1cGRhdGVJbnB1dChtdXRhdGlvbi50YXJnZXQpLFxuICAgIH0pO1xuICAgIGFsbEZyYW1lKChmcmFtZSkgPT5cbiAgICAgIGZyYW1lLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1hdHRyaWJ1dGVfdGFyZ2V0XVwiKVxuICAgICkuZm9yRWFjaCgoaW5wdXQpID0+IHVwZGF0ZUlucHV0KGlucHV0KSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUlucHV0KGlucHV0KSB7XG4gICAgY29uc3QgZWxTZWxlY3RvcklkID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1hdHRyaWJ1dGVfdGFyZ2V0XCIpO1xuICAgIGlmICghZWxTZWxlY3RvcklkKSByZXR1cm47XG5cbiAgICBsZXQgZWxlbWVudCA9IGFsbEZyYW1lKChmcmFtZSkgPT4gZnJhbWUucXVlcnlTZWxlY3RvcihlbFNlbGVjdG9ySWQpKVswXTtcblxuICAgIGxldCByZWFkID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1hdHRyaWJ1dGVfc3luY1wiKTtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShyZWFkKSlcbiAgICAgIGZyb21JbnB1dChpbnB1dCwgKHR5cGUsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5jbGFzcyA9PT0gXCJ0b2dnbGVcIilcbiAgICAgICAgICBpbnB1dC5jaGVja2VkID0gZnJvbUVsZW1lbnRUb0Jvb2xlYW4oe1xuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgaW5wdXRWYWx1ZTogaW5wdXQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIiksXG4gICAgICAgICAgICByZWFkLFxuICAgICAgICAgIH0pO1xuICAgICAgICBlbHNlIGlmIChpbnB1dC50YWdOYW1lID09IFwiU0VMRUNUXCIpIHtcbiAgICAgICAgICBmcm9tRWxlbWVudFRvU2VsZWN0KHsgaW5wdXQsIGVsZW1lbnQsIHJlYWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQudGFnTmFtZSA9PSBcIkNPQ1JFQVRFLVNFTEVDVFwiKSB7XG4gICAgICAgICAgZnJvbUVsZW1lbnRUb0NDU2VsZWN0KHsgaW5wdXQsIGVsZW1lbnQsIHJlYWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaW5wdXQubGFzdFZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgaW5wdXQudmFsdWUgPSBmcm9tRWxlbWVudFRvVGV4dCh7IGVsZW1lbnQsIHJlYWQgfSk7XG4gICAgICAgICAgLy8gdG9kbzogdXAgb3IgYm90dG9tIGlzIGNvcnJlY3Qgd2hpY2ggb25lP1xuICAgICAgICAgIC8vaW5wdXQudmFsdWUgPSBmcm9tRWxlbWVudFRvVGV4dCh7IGVsZW1lbnQsIHJlYWQgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDc3NSdWxlcyhzdHIpIHtcbiAgICBsZXQgc3R5bGVPYmplY3QgPSB7fTtcbiAgICBpZiAoc3RyLnNwbGl0KVxuICAgICAgc3RyLnNwbGl0KFwiO1wiKS5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICAgIGxldCBydWxlU3BsaXQgPSBydWxlLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgbGV0IGtleSA9IHJ1bGVTcGxpdC5zaGlmdCgpLnRyaW0oKTtcbiAgICAgICAgbGV0IHZhbHVlID0gcnVsZVNwbGl0LmpvaW4oKS50cmltKCk7XG4gICAgICAgIGlmIChrZXkpIHN0eWxlT2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG4gIFxuICBmdW5jdGlvbiBwYXJzZUNzc1J1bGVzQXNBcnJheShzdHIpIHtcbiAgICBpZiAoc3RyLnNwbGl0KVxuICAgICAgcmV0dXJuIHN0ci5zcGxpdChcIjtcIikuc2xpY2UoMCwtMSkubWFwKHN0ID0+IHN0LnRyaW0oKSlcbiAgICByZXR1cm4gW107XG4gIH1cbiAgXG5cbiAgZnVuY3Rpb24gYWxsRnJhbWUoY2FsbGJhY2spIHtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IFtmcmFtZU9iamVjdCwgZnJhbWVdIG9mIGFsbEZyYW1lcykge1xuICAgICAgbGV0IGNhbGxiYWNrUmVzdWx0ID0gY2FsbGJhY2soZnJhbWUuZG9jdW1lbnQsIGZyYW1lLndpbmRvdyk7XG4gICAgICBpZiAoXG4gICAgICAgIGNhbGxiYWNrUmVzdWx0ICYmXG4gICAgICAgIHR5cGVvZiBjYWxsYmFja1Jlc3VsdFtTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCJcbiAgICAgIClcbiAgICAgICAgY2FsbGJhY2tSZXN1bHQuZm9yRWFjaCgoZWwpID0+IHJlc3VsdC5hZGQoZWwpKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrUmVzdWx0KSByZXN1bHQuYWRkKGNhbGxiYWNrUmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHQpLmZpbHRlcihcbiAgICAgIChlbCkgPT4gIWZpbHRlcnMuc29tZSgoZmlsdGVyKSA9PiBlbC5tYXRjaGVzKGZpbHRlcikpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXQoeyB3aW5kb3dPYmplY3QsIGRvY09iamVjdCwgaXNJZnJhbWUsIGZyYW1lLCBvbkNvbGxhYm9yYXRpb24gPSAoKSA9PiB7fSB9KSB7XG4gICAgbGV0IHJlZjtcbiAgICB0b29scy5vbkNvbGxhYm9yYXRpb24gPSBvbkNvbGxhYm9yYXRpb247XG4gICAgaWYgKGlzSWZyYW1lKSB7XG4gICAgICBsZXQgZnJhbWVXaW5kb3cgPSBmcmFtZS5jb250ZW50V2luZG93O1xuICAgICAgbGV0IGZyYW1lRG9jdW1lbnQgPSBmcmFtZVdpbmRvdy5kb2N1bWVudCB8fCBmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG5cbiAgICAgIHJlZiA9IHtcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIHdpbmRvdzogZnJhbWVXaW5kb3csXG4gICAgICAgIGRvY3VtZW50OiBmcmFtZURvY3VtZW50LFxuICAgICAgICBpc0lmcmFtZTogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBhbGxGcmFtZXMuc2V0KGZyYW1lLCByZWYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlZiA9IHsgd2luZG93OiB3aW5kb3dPYmplY3QsIGRvY3VtZW50OiBkb2NPYmplY3QsIGlzSWZyYW1lOiBmYWxzZSB9O1xuICAgICAgYWxsRnJhbWVzLnNldChcIm1haW5cIiwgcmVmKTtcbiAgICB9XG5cbiAgICByZWYud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgIHJlZi53aW5kb3cuQ29DcmVhdGVPYnNlcnZlci5hZGQoe1xuICAgICAgICBvYnNlcnZlOiBbXCJhdHRyaWJ1dGVzXCIsIFwiY2hhcmFjdGVyRGF0YVwiXSxcbiAgICAgICAgdGFzazogKG11dGF0aW9uKSA9PiB0cmlnZ2VyRWxlbWVudE11dGF0aW9uKG11dGF0aW9uKSxcbiAgICAgIH0pO1xuXG4gICAgICByZWYud2luZG93LkNvQ3JlYXRlT2JzZXJ2ZXIuYWRkKHtcbiAgICAgICAgbmFtZTogXCJjY0F0dHJpYnV0ZVwiLFxuICAgICAgICBvYnNlcnZlOiBbXCJhdHRyaWJ1dGVzXCJdLFxuICAgICAgICBhdHRyaWJ1dGVzOiBbXCJkYXRhLWF0dHJpYnV0ZV90YXJnZXRcIl0sXG4gICAgICAgIHRhc2s6IChtdXRhdGlvbikgPT4gdXBkYXRlSW5wdXQobXV0YXRpb24udGFyZ2V0KSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmVmLndpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0QWxsU2VsZWN0ZWRPcHRpb25zID0gZnVuY3Rpb24gZ2V0QWxsU2VsZWN0ZWRPcHRpb25zKCkge1xuICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiBbc2VsZWN0ZWRdXCIpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20ob3B0aW9ucykubWFwKChvKSA9PiBvLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpKTtcbiAgICB9O1xuICAgIHJlZi53aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLmdldEFsbE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRBbGxPcHRpb25zKCkge1xuICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiB1bCA+IFt2YWx1ZV1cIik7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShvcHRpb25zKS5tYXAoKG8pID0+IG8uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikpO1xuICAgIH07XG4gIFxuXG4gICAgcmVmLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoZSkgPT4ge1xuICAgICAgbGV0IGlucHV0ID0gZS50YXJnZXQ7XG5cbiAgICAgIGNvbnN0IGVsU2VsZWN0b3JJZCA9IGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtYXR0cmlidXRlX3RhcmdldFwiKTtcbiAgICAgIGlmICghZWxTZWxlY3RvcklkKSByZXR1cm47XG4gICAgICBsZXQgZWxlbWVudHMgPSBhbGxGcmFtZSgoZG9jdW1lbnQpID0+XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxTZWxlY3RvcklkKVxuICAgICAgKTtcblxuICAgICAgbGV0IHJlYWQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWF0dHJpYnV0ZV9zeW5jXCIpO1xuXG4gICAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGZyb21JbnB1dChpbnB1dCwgKHR5cGUsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgICAgbGV0IHN0YXR1cyA9IGlucHV0W21ldGFkYXRhLnJlYWRdO1xuICAgICAgICAgICAgaWYgKHN0YXR1cykgX19hZGRUb0VsZW1lbnQoaW5wdXQsIGVsZW1lbnQsIHR5cGUsIHJlYWQpO1xuICAgICAgICAgICAgZWxzZSBfX3JlbW92ZVRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgdHlwZSwgcmVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgICAgICAgX19hZGRUb0VsZW1lbnQoaW5wdXQsIGVsZW1lbnQsIHR5cGUsIHJlYWQpO1xuXG4gICAgICAgICAgICBsZXQgaW5wdXRzID0gYWxsRnJhbWUoKGZyYW1lKSA9PlxuICAgICAgICAgICAgICBmcmFtZS5nZXRFbGVtZW50c0J5TmFtZShpbnB1dC5uYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlucHV0cyA9IEFycmF5LmZyb20oaW5wdXRzKTtcbiAgICAgICAgICAgIGxldCBvdXJJbnB1dEluZGV4ID0gaW5wdXRzLmluZGV4T2YoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKG91cklucHV0SW5kZXggIT09IC0xKSBkZWxldGUgaW5wdXRzW291cklucHV0SW5kZXhdO1xuXG4gICAgICAgICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0KSBfX3JlbW92ZVRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgdHlwZSwgcmVhZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEudHlwZSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkT3B0aW9ucyA9IGdldFNlbGVjdE9wdGlvbnMoaW5wdXQsIHRydWUpO1xuICAgICAgICAgICAgbGV0IHVuU2VsZWN0ZWRPcHRpb25zID0gZ2V0U2VsZWN0T3B0aW9ucyhpbnB1dCwgZmFsc2UpO1xuXG4gICAgICAgICAgICBfX2FkZFRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgc2VsZWN0ZWRPcHRpb25zLCByZWFkKTtcbiAgICAgICAgICAgIF9fcmVtb3ZlVG9FbGVtZW50KGlucHV0LCBlbGVtZW50LCB1blNlbGVjdGVkT3B0aW9ucywgcmVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLnR5cGUgPT09IFwiY29jcmVhdGUtc2VsZWN0XCIpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZE9wdGlvbnMyID0gaW5wdXQuZ2V0QWxsU2VsZWN0ZWRPcHRpb25zKCk7XG4gICAgICAgICAgICAvLyBsZXQgdW5TZWxlY3RlZE9wdGlvbnMyID0gaW5wdXRcbiAgICAgICAgICAgIC8vICAgLmdldEFsbE9wdGlvbnMoKVxuICAgICAgICAgICAgLy8gICAuZmlsdGVyKChvKSA9PiAhc2VsZWN0ZWRPcHRpb25zMi5pbmNsdWRlcyhvKSk7XG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgX19hZGRUb0VsZW1lbnQoaW5wdXQsIGVsZW1lbnQsIHNlbGVjdGVkT3B0aW9uczIsIHJlYWQpO1xuICAgICAgICAgICAgLy8gX19yZW1vdmVUb0VsZW1lbnQoaW5wdXQsIGVsZW1lbnQsIHVuU2VsZWN0ZWRPcHRpb25zMiwgcmVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX19yZW1vdmVUb0VsZW1lbnQoaW5wdXQsIGVsZW1lbnQsIFwibGFzdFZhbHVlXCIsIHJlYWQpO1xuICAgICAgICAgICAgX19hZGRUb0VsZW1lbnQoaW5wdXQsIGVsZW1lbnQsIHR5cGUsIHJlYWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGlmIChpbnB1dC50YWdOYW1lID09PSBcIkNPQ1JFQVRFLVNFTEVDVFwiICYmICFpbnB1dC5zZWxlY3RPcHRpb24pIHtcbiAgLy8gICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoY29jcmVhdGVVdGlsaXR5KSkge1xuICAvLyAgICAgaW5wdXRba10gPSB2O1xuICAvLyAgIH1cbiAgLy8gfVxuXG4gIGZ1bmN0aW9uIGFkZEZpbHRlcihzZWxlY3Rvcikge1xuICAgIGZpbHRlcnMucHVzaChzZWxlY3Rvcik7XG4gIH1cblxuICAvLyBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgLy8gICAvL2FkZCBjY19zZWxlY3RfdXRpbGl0eVxuICAvLyAgIGlmIChpbnB1dC50YWdOYW1lID09PSBcIkNPQ1JFQVRFLVNFTEVDVFwiKSB7XG4gIC8vICAgICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoY29jcmVhdGVVdGlsaXR5KSkge1xuICAvLyAgICAgICBpbnB1dFtrXSA9IHY7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyAgIGlucHV0QWRkRXZlbnRMaXN0ZW5lcihpbnB1dClcbiAgLy8gfSk7XG5cbiAgZnVuY3Rpb24gdHJpZ2dlckVsZW1lbnRNdXRhdGlvbihtdXRhdGlvbikge1xuICAgIGxldCBlbGVtZW50O1xuICAgIGxldCBhdHRyaWJ1dGVOYW1lO1xuXG4gICAgc3dpdGNoIChtdXRhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiYXR0cmlidXRlc1wiOlxuICAgICAgICBhdHRyaWJ1dGVOYW1lID0gbXV0YXRpb24uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgZWxlbWVudCA9IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2hhcmFjdGVyRGF0YVwiOlxuICAgICAgICBhdHRyaWJ1dGVOYW1lID0gXCJpbm5lclRleHRcIjtcbiAgICAgICAgZWxlbWVudCA9IG11dGF0aW9uLnRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50IHx8ICAoZWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtYXR0cmlidXRlX3N5bmNcIikpKSByZXR1cm47XG5cbiAgICBsZXQgY29ubmVjdGVkSW5wdXQgPSBhbGxGcmFtZSgoZnJhbWUpID0+XG4gICAgICBmcmFtZS5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtYXR0cmlidXRlX3RhcmdldF1cIilcbiAgICApLmZpbHRlcigoaW5wdXQpID0+IHtcbiAgICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWF0dHJpYnV0ZV9zeW5jXCIpICE9PSBhdHRyaWJ1dGVOYW1lKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBsZXQgcXVlcnkgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWF0dHJpYnV0ZV90YXJnZXRcIik7XG4gICAgICBsZXQgZWxlbWVudHMgPSBhbGxGcmFtZSgoZnJhbWUpID0+IGZyYW1lLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKTtcbiAgICAgIHJldHVybiBlbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KTtcbiAgICB9KTtcblxuICAgIGNvbm5lY3RlZElucHV0LmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBsZXQgcmVhZCA9IGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtYXR0cmlidXRlX3N5bmNcIik7XG4gICAgICBpZiAocmVhZCA9PT0gYXR0cmlidXRlTmFtZSlcbiAgICAgICAgZnJvbUlucHV0KGlucHV0LCAodHlwZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuY2xhc3MgPT09IFwidG9nZ2xlXCIpXG4gICAgICAgICAgICBpbnB1dC5jaGVja2VkID0gZnJvbUVsZW1lbnRUb0Jvb2xlYW4oe1xuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogaW5wdXQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIiksXG4gICAgICAgICAgICAgIHJlYWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBlbHNlIGlmIChpbnB1dC50YWdOYW1lID09IFwiU0VMRUNUXCIpIHtcbiAgICAgICAgICAgIGZyb21FbGVtZW50VG9TZWxlY3QoeyBpbnB1dCwgZWxlbWVudCwgcmVhZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaW5wdXQudGFnTmFtZSA9PSBcIkNPQ1JFQVRFLVNFTEVDVFwiKSB7XG4gICAgICAgICAgICBmcm9tRWxlbWVudFRvQ0NTZWxlY3QoeyBpbnB1dCwgZWxlbWVudCwgcmVhZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRWYWx1ZSA9IGZyb21FbGVtZW50VG9UZXh0KHsgZWxlbWVudCwgcmVhZCB9KTtcbiAgICAgICAgICAgIGlmIChpbnB1dC52YWx1ZS50cmltKCkgPT0gaW5wdXRWYWx1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgaW5wdXQubGFzdFZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQ2xhc3NMaXN0KHN0cikge1xuICAgIGlmIChzdHIuc3BsaXQpIHJldHVybiBzdHIuc3BsaXQoXCIgXCIpLm1hcChzdCA9PiBzdC50cmltKCkpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3Vic2V0KG9iajEsIG9iajIpIHtcbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqMikpIHtcbiAgICAgIGlmIChvYmoxW2tleV0gIT09IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUlucHV0KGlucHV0LCBjYWxsYmFjaykge1xuICAgIHN3aXRjaCAoaW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgc3dpdGNoIChpbnB1dC50eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgIGNhc2UgXCJjb2xvclwiOlxuICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICBjYWxsYmFjayhcInZhbHVlXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgICBjYWxsYmFjayhcInZhbHVlXCIsIHtcbiAgICAgICAgICAgICAgY2xhc3M6IFwidG9nZ2xlXCIsXG4gICAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgcmVhZDogXCJjaGVja2VkXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICAgICAgY2FsbGJhY2soXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAgIGNsYXNzOiBcInRvZ2dsZVwiLFxuICAgICAgICAgICAgICB0eXBlOiBcInJhZGlvXCIsXG4gICAgICAgICAgICAgIHJlYWQ6IFwiY2hlY2tlZFwiLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjayhcInZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBjYWxsYmFjayhcInZhbHVlXCIsIHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgICAgICAgIGNsYXNzOiBpbnB1dC5tdWx0aXBsZSA/IFwibXVsdGlzZWxlY3RcIiA6IFwic2VsZWN0XCIsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICBjYWxsYmFjayhcInZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb2NyZWF0ZS1zZWxlY3RcIjpcbiAgICAgICAgY2FsbGJhY2soXCJDT0NSRUFURS1TRUxFQ1RcIiwge1xuICAgICAgICAgIHR5cGU6IFwiY29jcmVhdGUtc2VsZWN0XCIsXG4gICAgICAgICAgY2xhc3M6IGlucHV0Lm11bHRpcGxlID8gXCJtdWx0aXNlbGVjdFwiIDogXCJzZWxlY3RcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGlucHV0LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPT0gbnVsbClcbiAgICAgICAgICBjYWxsYmFjayhcImlubmVyVGV4dFwiKTtcbiAgICAgICAgZWxzZSBjYWxsYmFjayhcInZhbHVlXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21FbGVtZW50VG9Cb29sZWFuKHsgaW5wdXQsIGVsZW1lbnQsIGlucHV0VmFsdWUsIHJlYWQgfSkge1xuICAgIHN3aXRjaCAocmVhZCkge1xuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIGxldCBwYXJzZWRDc3MgPSBwYXJzZUNzc1J1bGVzKGlucHV0VmFsdWUpO1xuICAgICAgICBsZXQgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZTtcblxuICAgICAgICByZXR1cm4gaXNTdWJzZXQoZWxlbWVudFN0eWxlLCBwYXJzZWRDc3MpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgIGxldCBjbGFzc0xpc3QgPSBwYXJzZUNsYXNzTGlzdChpbnB1dFZhbHVlKTtcbiAgICAgICAgbGV0IHRhcmdldENsYXNzTGlzdCA9IEFycmF5LmZyb20oZWxlbWVudC5jbGFzc0xpc3QpO1xuICAgICAgICByZXR1cm4gY2xhc3NMaXN0LmV2ZXJ5KChjbGFzc05hbWUpID0+XG4gICAgICAgICAgdGFyZ2V0Q2xhc3NMaXN0LmluY2x1ZGVzKGNsYXNzTmFtZSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShyZWFkKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tRWxlbWVudFRvVGV4dCh7IGVsZW1lbnQsIHJlYWQgfSkge1xuICAgIHN3aXRjaCAocmVhZCkge1xuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShyZWFkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LnRvU3RyaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlubmVyVGV4dFwiOlxuICAgICAgICByZXR1cm4gZWxlbWVudC5pbm5lclRleHQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUocmVhZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19hZGRUb0VsZW1lbnQoaW5wdXQsIGVsZW1lbnQsIHR5cGUsIHJlYWQsIHZhbHVlcykge1xuICAgIGlmICghdmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIpIHZhbHVlcyA9IHR5cGU7XG4gICAgICBlbHNlIHZhbHVlcyA9IFtpbnB1dC5nZXRBdHRyaWJ1dGUodHlwZSkgfHwgaW5wdXRbdHlwZV1dO1xuICAgICAgY29sbGFib3JhdGUoeyBtZXRob2Q6IFwiYWRkXCIsIHZhbHVlcywgZWxlbWVudCwgdHlwZSwgcmVhZCB9KTtcbiAgICB9XG4gICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICBzd2l0Y2ggKHJlYWQpIHtcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuICAgICAgICAgIGxldCBwYXJzZWRDc3MgPSBwYXJzZUNzc1J1bGVzKHZhbHVlKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHBhcnNlZENzcyk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgLy8gdmFsdWVcbiAgICAgICAgICAvLyAgIC5zcGxpdChcIiBcIilcbiAgICAgICAgICAvLyAgIC5mb3JFYWNoKChjbGFzc25hbWUpID0+IGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc25hbWUpKTtcbiAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIC5zcGxpdChcIiBcIilcbiAgICAgICAgICAgIC5mb3JFYWNoKFxuICAgICAgICAgICAgICAoY2xhc3NuYW1lKSA9PiBjbGFzc25hbWUgJiYgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzbmFtZSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlubmVyVGV4dFwiOlxuICAgICAgICAgIGVsZW1lbnRbcmVhZF0gPSB2YWx1ZTtcbiAgICAgICAgICB0cmlnZ2VyRWxlbWVudE11dGF0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgICAgICAgICAgdGFyZ2V0OiB7IHBhcmVudEVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUocmVhZCwgdmFsdWUpO1xuICAgICAgICAgIGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocmVhZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBfX3JlbW92ZVRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgdHlwZSwgcmVhZCwgdmFsdWVzKSB7XG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIikgdmFsdWVzID0gdHlwZTtcbiAgICAgIGVsc2UgdmFsdWVzID0gW2lucHV0LmdldEF0dHJpYnV0ZSh0eXBlKSB8fCBpbnB1dFt0eXBlXV07XG4gICAgICBjb2xsYWJvcmF0ZSh7IG1ldGhvZDogXCJyZW1vdmVcIiwgdmFsdWVzLCBlbGVtZW50LCB0eXBlLCByZWFkIH0pO1xuICAgIH1cbiAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIHN3aXRjaCAocmVhZCkge1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG4gICAgICAgICAgbGV0IHBhcnNlZENzcyA9IHBhcnNlQ3NzUnVsZXModmFsdWUpO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHBhcnNlZENzcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyc2VkQ3NzW2tleV0pIGVsZW1lbnQuc3R5bGVba2V5XSA9IFwiXCI7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgLy8gdmFsdWVcbiAgICAgICAgICAvLyAgIC5zcGxpdChcIiBcIilcbiAgICAgICAgICAvLyAgIC5mb3JFYWNoKChjbGFzc25hbWUpID0+IGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc25hbWUpKTtcbiAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIC5zcGxpdChcIiBcIilcbiAgICAgICAgICAgIC5mb3JFYWNoKFxuICAgICAgICAgICAgICAoY2xhc3NuYW1lKSA9PiBjbGFzc25hbWUgJiYgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzbmFtZSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShyZWFkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdE9wdGlvbnMoc2VsZWN0LCBzdGF0ZSkge1xuICAgIGxldCBvcHRpb25zID0gQXJyYXkuZnJvbShzZWxlY3Qub3B0aW9ucyk7XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgICAgIC5maWx0ZXIoKG8pID0+IChzdGF0ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG8uc2VsZWN0ZWQgPT0gc3RhdGUpKVxuICAgICAgLm1hcCgobykgPT4gby52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdEVxdWFsKG9iamVjdDEsIG9iamVjdDIpIHtcbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0MSkpXG4gICAgICBpZiAob2JqZWN0MVtrZXldICE9PSBvYmplY3QyW2tleV0gfHwgb2JqZWN0MVtrZXldID09PSBcIlwiKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21FbGVtZW50VG9TZWxlY3QoeyBpbnB1dCwgZWxlbWVudCwgcmVhZCB9KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGlucHV0Lm9wdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHN3aXRjaCAocmVhZCkge1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBsZXQgcGFyc2VkID0gcGFyc2VDc3NSdWxlcyhpbnB1dC5vcHRpb25zW2ldLnZhbHVlKTtcblxuICAgICAgICAgIGlmIChpc09iamVjdEVxdWFsKHBhcnNlZCwgZWxlbWVudC5zdHlsZSkpXG4gICAgICAgICAgICBpbnB1dC5vcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBlbHNlIGlucHV0Lm9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAvLyBpZih1blN0eWxlLnNvbWUoc3R5bGUgPT4gaXNPYmplY3RFcXVhbChwYXJzZWQsIHN0eWxlKSkpXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGlucHV0Lm9wdGlvbnNbaV0udmFsdWUpKVxuICAgICAgICAgICAgaW5wdXQub3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgZWxzZSBpbnB1dC5vcHRpb25zW2ldLnNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUocmVhZCkgPT0gaW5wdXQub3B0aW9uc1tpXS52YWx1ZSlcbiAgICAgICAgICAgIGlucHV0Lm9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGVsc2UgaW5wdXQub3B0aW9uc1tpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21FbGVtZW50VG9DQ1NlbGVjdCh7IGlucHV0LCBlbGVtZW50LCByZWFkIH0pIHtcbiAgICBsZXQgb3B0aW9ucywgc2VsT3B0aW9ucyA9IFtdLCBzZWxPcHRpb25zMjtcblxuICAgIHN3aXRjaCAocmVhZCkge1xuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIC8vIG9wdGlvbnMgPSBpbnB1dC5nZXRBbGxPcHRpb25zKCk7XG5cbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gICBsZXQgcGFyc2VkID0gcGFyc2VDc3NSdWxlcyhvcHRpb25zW2ldKTtcblxuICAgICAgICAvLyAgIGlmIChpc09iamVjdEVxdWFsKHBhcnNlZCwgZWxlbWVudC5zdHlsZSkpXG4gICAgICAgIC8vICAgICBzZWxPcHRpb25zLnB1c2goIG9wdGlvbnNbaV0gKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBDb0NyZWF0ZVNlbGVjdC5yZW5kZXJWYWx1ZShpbnB1dCwgc2VsT3B0aW9ucylcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAgIHNlbE9wdGlvbnMyID0gcGFyc2VDc3NSdWxlc0FzQXJyYXkoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpXG4gICAgICAgICAgQ29DcmVhdGVTZWxlY3QucmVuZGVyVmFsdWUoaW5wdXQsIHNlbE9wdGlvbnMyKVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAvLyBvcHRpb25zID0gaW5wdXQuZ2V0QWxsT3B0aW9ucygpO1xuICAgICAgICAvLyBmb3IgKGxldCBpID0gMCwgbGVuID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhvcHRpb25zW2ldKSlcbiAgICAgICAgLy8gICAgIHNlbE9wdGlvbnMucHVzaCggb3B0aW9uc1tpXSApO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIENvQ3JlYXRlU2VsZWN0LnJlbmRlclZhbHVlKGlucHV0LCBzZWxPcHRpb25zKVxuICAgICAgICAgIHNlbE9wdGlvbnMyID0gcGFyc2VDbGFzc0xpc3QoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpXG4gICAgICAgICAgQ29DcmVhdGVTZWxlY3QucmVuZGVyVmFsdWUoaW5wdXQsIHNlbE9wdGlvbnMyKVxuICAgICAgICBcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUocmVhZCkpXG4gICAgICAgICAgQ29DcmVhdGVTZWxlY3QucmVuZGVyVmFsdWUoaW5wdXQsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKHJlYWQpKVxuICAgICAgICAvLyB0b2RvOiBtaWdodCBicmVha1xuICAgICAgICAvLyBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUocmVhZCkgPT0gb3B0aW9uc1tpXSlcbiAgICAgICAgLy8gICBpbnB1dC5zZWxlY3RPcHRpb24ob3B0aW9uc1tpXSk7XG4gICAgICAgIC8vIGVsc2UgaW5wdXQudW5zZWxlY3RPcHRpb24ob3B0aW9uc1tpXSk7XG4gICAgfVxuXG4gIH1cblxuICBDb0NyZWF0ZVNvY2tldC5saXN0ZW4oXCJjY0F0dHJpYnV0ZVwiLCBmdW5jdGlvbih7XG4gICAgbWV0aG9kLFxuICAgIHZhbHVlcyxcbiAgICBlbGVtZW50LFxuICAgIHR5cGUsXG4gICAgcmVhZCxcbiAgfSkge1xuICAgIGVsZW1lbnQgPSBhbGxGcmFtZSgoZnJhbWUpID0+XG4gICAgICBmcmFtZS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtZWxlbWVudF9pZD1cIiArIGVsZW1lbnQgKyBcIl1cIilcbiAgICApWzBdO1xuICAgIGlmIChtZXRob2QgPT09IFwiYWRkXCIpIHtcbiAgICAgIF9fYWRkVG9FbGVtZW50KG51bGwsIGVsZW1lbnQsIHR5cGUsIHJlYWQsIHZhbHVlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZW1vdmVcIikge1xuICAgICAgX19yZW1vdmVUb0VsZW1lbnQobnVsbCwgZWxlbWVudCwgdHlwZSwgcmVhZCwgdmFsdWVzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGNvbGxhYm9yYXRlKGRhdGEpIHtcbiAgICB0b29scy5vbkNvbGxhYm9yYXRpb24oe1xuICAgICAgdmFsdWU6IEFycmF5LmlzQXJyYXkoZGF0YS52YWx1ZXMpID8gZGF0YS52YWx1ZXMuam9pbignICcpIDogZGF0YS52YWx1ZXMsXG4gICAgICByZWFkOiBkYXRhLnJlYWQsXG4gICAgICBlbGVtZW50OiBkYXRhLmVsZW1lbnQsXG5cbiAgICB9KTtcblxuICAgIENvQ3JlYXRlLnNlbmRNZXNzYWdlKHtcbiAgICAgIGJyb2FkY2FzdF9zZW5kZXI6IGZhbHNlLFxuICAgICAgcm9vbXM6IFwiXCIsXG4gICAgICBlbWl0OiB7XG4gICAgICAgIG1lc3NhZ2U6IFwiY2NBdHRyaWJ1dGVcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgZWxlbWVudDogZGF0YS5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudF9pZFwiKSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbiAgXG4gIGV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlQXR0cmlidXRlO1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/CoCreate-attributes.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/CoCreate-attributes.js");
/******/ })()
.default;
});