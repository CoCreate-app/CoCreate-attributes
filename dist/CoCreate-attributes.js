/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CoCreateAttributes"] = factory();
	else
		root["CoCreateAttributes"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/CoCreate-attributes.js":
/*!************************************!*\
  !*** ./src/CoCreate-attributes.js ***!
  \************************************/
/***/ (() => {

eval("function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * refactor:\n * refactor mutation observer to a component\n * refactor cc_select_utility, allFrame, parseCssRules, parseClassList to a global/general workspace\n */\n(function () {\n  //store all frames\n  var filters = [];\n  var allFrames = new Map();\n  var tools = {};\n  window.ccAttribute = {\n    init: init,\n    addFilter: addFilter\n  }; // first time load\n\n  window.addEventListener(\"load\", function () {\n    init({\n      windowObject: window,\n      docObject: document\n    });\n    window.CoCreateObserver.add({\n      observe: [\"attributes\", \"characterData\"],\n      task: function task(mutation) {\n        return triggerElementMutation(mutation);\n      }\n    });\n    window.CoCreateObserver.add({\n      name: \"ccAttribute\",\n      observe: [\"attributes\"],\n      attributes: [\"data-attribute_target\"],\n      task: function task(mutation) {\n        return updateInput(mutation.target);\n      }\n    });\n    allFrame(function (frame) {\n      return frame.querySelectorAll(\"[data-attribute_target]\");\n    }).forEach(function (input) {\n      return updateInput(input);\n    });\n  });\n\n  function updateInput(input) {\n    var elSelectorId = input.getAttribute(\"data-attribute_target\");\n    if (!elSelectorId) return;\n    var element = allFrame(function (frame) {\n      return frame.querySelector(elSelectorId);\n    })[0];\n    var read = input.getAttribute(\"data-attribute_sync\");\n    if (element && element.getAttribute(read)) fromInput(input, function (type, metadata) {\n      if (metadata && metadata[\"class\"] === \"toggle\") input.checked = fromElementToBoolean({\n        input: input,\n        element: element,\n        inputValue: input.getAttribute(\"value\"),\n        read: read\n      });else if (input.tagName == \"SELECT\") {\n        fromElementToSelect({\n          input: input,\n          element: element,\n          read: read\n        });\n      } else if (input.tagName == \"COCREATE-SELECT\") {\n        fromElementToCCSelect({\n          input: input,\n          element: element,\n          read: read\n        });\n      } else {\n        input.lastValue = input.value;\n        input.value = fromElementToText({\n          element: element,\n          read: read\n        }); // todo: up or bottom is correct which one?\n        //input.value = fromElementToText({ element, read });\n      }\n    });\n  }\n\n  function parseCssRules(str) {\n    var styleObject = {};\n    if (str.split) str.split(\";\").forEach(function (rule) {\n      var ruleSplit = rule.split(\":\");\n      var key = ruleSplit.shift().trim();\n      var value = ruleSplit.join().trim();\n      if (key) styleObject[key] = value;\n    });\n    return styleObject;\n  }\n\n  function parseCssRulesAsArray(str) {\n    if (str.split) return str.split(\";\").slice(0, -1).map(function (st) {\n      return st.trim();\n    });\n    return [];\n  }\n\n  function allFrame(callback) {\n    var result = new Set();\n\n    var _iterator = _createForOfIteratorHelper(allFrames),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            frameObject = _step$value[0],\n            frame = _step$value[1];\n\n        var callbackResult = callback(frame.document, frame.window);\n        if (callbackResult && typeof callbackResult[Symbol.iterator] === \"function\") callbackResult.forEach(function (el) {\n          return result.add(el);\n        });else if (callbackResult) result.add(callbackResult);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return Array.from(result).filter(function (el) {\n      return !filters.some(function (filter) {\n        return el.matches(filter);\n      });\n    });\n  }\n\n  function init(_ref) {\n    var windowObject = _ref.windowObject,\n        docObject = _ref.docObject,\n        isIframe = _ref.isIframe,\n        frame = _ref.frame,\n        _ref$onCollaboration = _ref.onCollaboration,\n        onCollaboration = _ref$onCollaboration === void 0 ? function () {} : _ref$onCollaboration;\n    var ref;\n    tools.onCollaboration = onCollaboration;\n\n    if (isIframe) {\n      var frameWindow = frame.contentWindow;\n      var frameDocument = frameWindow.document || frame.contentDocument;\n      ref = {\n        frame: frame,\n        window: frameWindow,\n        document: frameDocument,\n        isIframe: true\n      };\n      allFrames.set(frame, ref);\n    } else {\n      ref = {\n        window: windowObject,\n        document: docObject,\n        isIframe: false\n      };\n      allFrames.set(\"main\", ref);\n    }\n\n    ref.window.addEventListener(\"load\", function () {\n      ref.window.CoCreateObserver.add({\n        observe: [\"attributes\", \"characterData\"],\n        task: function task(mutation) {\n          return triggerElementMutation(mutation);\n        }\n      });\n      ref.window.CoCreateObserver.add({\n        name: \"ccAttribute\",\n        observe: [\"attributes\"],\n        attributes: [\"data-attribute_target\"],\n        task: function task(mutation) {\n          return updateInput(mutation.target);\n        }\n      });\n    });\n\n    ref.window.HTMLElement.prototype.getAllSelectedOptions = function getAllSelectedOptions() {\n      var options = this.querySelectorAll(\":scope > [selected]\");\n      return Array.from(options).map(function (o) {\n        return o.getAttribute(\"value\");\n      });\n    };\n\n    ref.window.HTMLElement.prototype.getAllOptions = function getAllOptions() {\n      var options = this.querySelectorAll(\":scope > ul > [value]\");\n      return Array.from(options).map(function (o) {\n        return o.getAttribute(\"value\");\n      });\n    };\n\n    ref.document.addEventListener(\"input\", function (e) {\n      var input = e.target;\n      var elSelectorId = input.getAttribute(\"data-attribute_target\");\n      if (!elSelectorId) return;\n      var elements = allFrame(function (document) {\n        return document.querySelector(elSelectorId);\n      });\n      var read = e.target.getAttribute(\"data-attribute_sync\");\n      elements.forEach(function (element) {\n        fromInput(input, function (type, metadata) {\n          if (metadata && metadata.type === \"checkbox\") {\n            var status = input[metadata.read];\n            if (status) __addToElement(input, element, type, read);else __removeToElement(input, element, type, read);\n          } else if (metadata && metadata.type === \"radio\") {\n            __addToElement(input, element, type, read);\n\n            var inputs = allFrame(function (frame) {\n              return frame.getElementsByName(input.name);\n            });\n            inputs = Array.from(inputs);\n            var ourInputIndex = inputs.indexOf(input);\n            if (ourInputIndex !== -1) delete inputs[ourInputIndex];\n            inputs.forEach(function (input) {\n              if (input) __removeToElement(input, element, type, read);\n            });\n          } else if (metadata && metadata.type === \"select\") {\n            var selectedOptions = getSelectOptions(input, true);\n            var unSelectedOptions = getSelectOptions(input, false);\n\n            __addToElement(input, element, selectedOptions, read);\n\n            __removeToElement(input, element, unSelectedOptions, read);\n          } else if (metadata && metadata.type === \"cocreate-select\") {\n            var selectedOptions2 = input.getAllSelectedOptions(); // let unSelectedOptions2 = input\n            //   .getAllOptions()\n            //   .filter((o) => !selectedOptions2.includes(o));\n\n            __addToElement(input, element, selectedOptions2, read); // __removeToElement(input, element, unSelectedOptions2, read);\n\n          } else {\n            __removeToElement(input, element, \"lastValue\", read);\n\n            __addToElement(input, element, type, read);\n          }\n        });\n      });\n    });\n  } // if (input.tagName === \"COCREATE-SELECT\" && !input.selectOption) {\n  //   for (let [k, v] of Object.entries(cocreateUtility)) {\n  //     input[k] = v;\n  //   }\n  // }\n\n\n  function addFilter(selector) {\n    filters.push(selector);\n  } // inputs.forEach((input) => {\n  //   //add cc_select_utility\n  //   if (input.tagName === \"COCREATE-SELECT\") {\n  //     for (let [k, v] of Object.entries(cocreateUtility)) {\n  //       input[k] = v;\n  //     }\n  //   }\n  //   inputAddEventListener(input)\n  // });\n\n\n  function triggerElementMutation(mutation) {\n    var element;\n    var attributeName;\n\n    switch (mutation.type) {\n      case \"attributes\":\n        attributeName = mutation.attributeName;\n        element = mutation.target;\n        break;\n\n      case \"characterData\":\n        attributeName = \"innerText\";\n        element = mutation.target.parentElement;\n        break;\n    }\n\n    if (!element || element && element.getAttribute(\"data-attribute_sync\")) return;\n    var connectedInput = allFrame(function (frame) {\n      return frame.querySelectorAll(\"[data-attribute_target]\");\n    }).filter(function (input) {\n      if (input.getAttribute(\"data-attribute_sync\") !== attributeName) return false;\n      var query = input.getAttribute(\"data-attribute_target\");\n      var elements = allFrame(function (frame) {\n        return frame.querySelectorAll(query);\n      });\n      return elements.includes(element);\n    });\n    connectedInput.forEach(function (input) {\n      var read = input.getAttribute(\"data-attribute_sync\");\n      if (read === attributeName) fromInput(input, function (type, metadata) {\n        if (metadata && metadata[\"class\"] === \"toggle\") input.checked = fromElementToBoolean({\n          input: input,\n          element: element,\n          inputValue: input.getAttribute(\"value\"),\n          read: read\n        });else if (input.tagName == \"SELECT\") {\n          fromElementToSelect({\n            input: input,\n            element: element,\n            read: read\n          });\n        } else if (input.tagName == \"COCREATE-SELECT\") {\n          fromElementToCCSelect({\n            input: input,\n            element: element,\n            read: read\n          });\n        } else {\n          var inputValue = fromElementToText({\n            element: element,\n            read: read\n          });\n          if (input.value.trim() == inputValue) return;\n          input.lastValue = input.value;\n          input.value = inputValue;\n        }\n      });\n    });\n  }\n\n  function parseClassList(str) {\n    if (str.split) return str.split(\" \").map(function (st) {\n      return st.trim();\n    });\n    return [];\n  }\n\n  function isSubset(obj1, obj2) {\n    for (var _i2 = 0, _Object$entries = Object.entries(obj2); _i2 < _Object$entries.length; _i2++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n\n      if (obj1[key] !== value) return false;\n    }\n\n    return true;\n  }\n\n  function fromInput(input, callback) {\n    switch (input.tagName.toLowerCase()) {\n      case \"input\":\n        switch (input.type.toLowerCase()) {\n          case \"text\":\n          case \"color\":\n          case \"date\":\n            callback(\"value\");\n            break;\n\n          case \"checkbox\":\n            callback(\"value\", {\n              \"class\": \"toggle\",\n              type: \"checkbox\",\n              read: \"checked\"\n            });\n            break;\n\n          case \"radio\":\n            callback(\"value\", {\n              \"class\": \"toggle\",\n              type: \"radio\",\n              read: \"checked\"\n            });\n            break;\n\n          default:\n            callback(\"value\");\n        }\n\n        break;\n\n      case \"select\":\n        callback(\"value\", {\n          type: \"select\",\n          \"class\": input.multiple ? \"multiselect\" : \"select\"\n        });\n        break;\n\n      case \"textarea\":\n        callback(\"value\");\n        break;\n\n      case \"cocreate-select\":\n        callback(\"COCREATE-SELECT\", {\n          type: \"cocreate-select\",\n          \"class\": input.multiple ? \"multiselect\" : \"select\"\n        });\n        break;\n\n      default:\n        if (input.getAttribute(\"contenteditable\") !== null) callback(\"innerText\");else callback(\"value\");\n    }\n  }\n\n  function fromElementToBoolean(_ref2) {\n    var input = _ref2.input,\n        element = _ref2.element,\n        inputValue = _ref2.inputValue,\n        read = _ref2.read;\n\n    switch (read) {\n      case \"style\":\n        var parsedCss = parseCssRules(inputValue);\n        var elementStyle = element.style;\n        return isSubset(elementStyle, parsedCss);\n        break;\n\n      case \"class\":\n        var classList = parseClassList(inputValue);\n        var targetClassList = Array.from(element.classList);\n        return classList.every(function (className) {\n          return targetClassList.includes(className);\n        });\n        break;\n\n      default:\n        return element.getAttribute(read) ? true : false;\n    }\n  }\n\n  function fromElementToText(_ref3) {\n    var element = _ref3.element,\n        read = _ref3.read;\n\n    switch (read) {\n      case \"style\":\n        return element.getAttribute(read);\n        break;\n\n      case \"class\":\n        return element.classList.toString();\n        break;\n\n      case \"innerText\":\n        return element.innerText;\n        break;\n\n      default:\n        return element.getAttribute(read);\n    }\n  }\n\n  function __addToElement(input, element, type, read, values) {\n    if (!values) {\n      if (_typeof(type) === \"object\") values = type;else values = [input.getAttribute(type) || input[type]];\n      collaborate({\n        method: \"add\",\n        values: values,\n        element: element,\n        type: type,\n        read: read\n      });\n    }\n\n    values.forEach(function (value) {\n      switch (read) {\n        case \"style\":\n          if (!value) return;\n          var parsedCss = parseCssRules(value);\n          Object.assign(element.style, parsedCss);\n          break;\n\n        case \"class\":\n          // value\n          //   .split(\" \")\n          //   .forEach((classname) => element.classList.remove(classname));\n          if (!value) return;\n          value.split(\" \").forEach(function (classname) {\n            return classname && element.classList.add(classname);\n          });\n          break;\n\n        case \"innerText\":\n          element[read] = value;\n          triggerElementMutation({\n            type: \"characterData\",\n            target: {\n              parentElement: element\n            }\n          });\n          break;\n\n        default:\n          if (value) element.setAttribute(read, value);else element.removeAttribute(read);\n      }\n    });\n  }\n\n  function __removeToElement(input, element, type, read, values) {\n    if (!values) {\n      if (_typeof(type) === \"object\") values = type;else values = [input.getAttribute(type) || input[type]];\n      collaborate({\n        method: \"remove\",\n        values: values,\n        element: element,\n        type: type,\n        read: read\n      });\n    }\n\n    values.forEach(function (value) {\n      switch (read) {\n        case \"style\":\n          if (!value) return;\n          var parsedCss = parseCssRules(value);\n          Object.keys(parsedCss).forEach(function (key) {\n            if (parsedCss[key]) element.style[key] = \"\";\n          });\n          break;\n\n        case \"class\":\n          // value\n          //   .split(\" \")\n          //   .forEach((classname) => element.classList.remove(classname));\n          if (!value) return;\n          value.split(\" \").forEach(function (classname) {\n            return classname && element.classList.remove(classname);\n          });\n          break;\n\n        default: // element.removeAttribute(read);\n\n      }\n    });\n  }\n\n  function getSelectOptions(select, state) {\n    var options = Array.from(select.options);\n    return options.filter(function (o) {\n      return state === undefined ? true : o.selected == state;\n    }).map(function (o) {\n      return o.value;\n    });\n  }\n\n  function isObjectEqual(object1, object2) {\n    for (var _i3 = 0, _Object$entries2 = Object.entries(object1); _i3 < _Object$entries2.length; _i3++) {\n      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),\n          key = _Object$entries2$_i[0],\n          value = _Object$entries2$_i[1];\n\n      if (object1[key] !== object2[key] || object1[key] === \"\") return false;\n    }\n\n    return true;\n  }\n\n  function fromElementToSelect(_ref4) {\n    var input = _ref4.input,\n        element = _ref4.element,\n        read = _ref4.read;\n\n    for (var i = 0, len = input.options.length; i < len; i++) {\n      switch (read) {\n        case \"style\":\n          var parsed = parseCssRules(input.options[i].value);\n          if (isObjectEqual(parsed, element.style)) input.options[i].selected = true;else input.options[i].selected = false; // if(unStyle.some(style => isObjectEqual(parsed, style)))\n\n          break;\n\n        case \"class\":\n          if (element.classList.contains(input.options[i].value)) input.options[i].selected = true;else input.options[i].selected = false;\n          break;\n\n        default:\n          if (element.getAttribute(read) == input.options[i].value) input.options[i].selected = true;else input.options[i].selected = false;\n      }\n    }\n  }\n\n  function fromElementToCCSelect(_ref5) {\n    var input = _ref5.input,\n        element = _ref5.element,\n        read = _ref5.read;\n    var options,\n        selOptions = [],\n        selOptions2;\n\n    switch (read) {\n      case \"style\":\n        // options = input.getAllOptions();\n        // for (let i = 0, len = options.length; i < len; i++) {\n        //   let parsed = parseCssRules(options[i]);\n        //   if (isObjectEqual(parsed, element.style))\n        //     selOptions.push( options[i] );\n        // }\n        // CoCreateSelect.renderValue(input, selOptions)\n        selOptions2 = parseCssRulesAsArray(element.getAttribute('style'));\n        CoCreateSelect.renderValue(input, selOptions2);\n        break;\n\n      case \"class\":\n        // options = input.getAllOptions();\n        // for (let i = 0, len = options.length; i < len; i++) {\n        //   if (element.classList.contains(options[i]))\n        //     selOptions.push( options[i] );\n        // }\n        // CoCreateSelect.renderValue(input, selOptions)\n        selOptions2 = parseClassList(element.getAttribute('class'));\n        CoCreateSelect.renderValue(input, selOptions2);\n        break;\n\n      default:\n        if (element.getAttribute(read)) CoCreateSelect.renderValue(input, element.getAttribute(read));\n      // todo: might break\n      // if (element.getAttribute(read) == options[i])\n      //   input.selectOption(options[i]);\n      // else input.unselectOption(options[i]);\n    }\n  }\n\n  CoCreateSocket.listen(\"ccAttribute\", function (_ref6) {\n    var method = _ref6.method,\n        values = _ref6.values,\n        element = _ref6.element,\n        type = _ref6.type,\n        read = _ref6.read;\n    element = allFrame(function (frame) {\n      return frame.querySelector(\"[data-element_id=\" + element + \"]\");\n    })[0];\n\n    if (method === \"add\") {\n      __addToElement(null, element, type, read, values);\n    } else if (method === \"remove\") {\n      __removeToElement(null, element, type, read, values);\n    }\n  });\n\n  function collaborate(data) {\n    tools.onCollaboration({\n      value: Array.isArray(data.values) ? data.values.join(' ') : data.values,\n      read: data.read,\n      element: data.element\n    });\n    CoCreate.sendMessage({\n      broadcast_sender: false,\n      rooms: \"\",\n      emit: {\n        message: \"ccAttribute\",\n        data: _objectSpread(_objectSpread({}, data), {}, {\n          element: data.element.getAttribute(\"data-element_id\")\n        })\n      }\n    });\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZUF0dHJpYnV0ZXMvLi9zcmMvQ29DcmVhdGUtYXR0cmlidXRlcy5qcz82OWMxIl0sIm5hbWVzIjpbImZpbHRlcnMiLCJhbGxGcmFtZXMiLCJNYXAiLCJ0b29scyIsIndpbmRvdyIsImNjQXR0cmlidXRlIiwiaW5pdCIsImFkZEZpbHRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJ3aW5kb3dPYmplY3QiLCJkb2NPYmplY3QiLCJkb2N1bWVudCIsIkNvQ3JlYXRlT2JzZXJ2ZXIiLCJhZGQiLCJvYnNlcnZlIiwidGFzayIsIm11dGF0aW9uIiwidHJpZ2dlckVsZW1lbnRNdXRhdGlvbiIsIm5hbWUiLCJhdHRyaWJ1dGVzIiwidXBkYXRlSW5wdXQiLCJ0YXJnZXQiLCJhbGxGcmFtZSIsImZyYW1lIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJpbnB1dCIsImVsU2VsZWN0b3JJZCIsImdldEF0dHJpYnV0ZSIsImVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwicmVhZCIsImZyb21JbnB1dCIsInR5cGUiLCJtZXRhZGF0YSIsImNoZWNrZWQiLCJmcm9tRWxlbWVudFRvQm9vbGVhbiIsImlucHV0VmFsdWUiLCJ0YWdOYW1lIiwiZnJvbUVsZW1lbnRUb1NlbGVjdCIsImZyb21FbGVtZW50VG9DQ1NlbGVjdCIsImxhc3RWYWx1ZSIsInZhbHVlIiwiZnJvbUVsZW1lbnRUb1RleHQiLCJwYXJzZUNzc1J1bGVzIiwic3RyIiwic3R5bGVPYmplY3QiLCJzcGxpdCIsInJ1bGUiLCJydWxlU3BsaXQiLCJrZXkiLCJzaGlmdCIsInRyaW0iLCJqb2luIiwicGFyc2VDc3NSdWxlc0FzQXJyYXkiLCJzbGljZSIsIm1hcCIsInN0IiwiY2FsbGJhY2siLCJyZXN1bHQiLCJTZXQiLCJmcmFtZU9iamVjdCIsImNhbGxiYWNrUmVzdWx0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJlbCIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsInNvbWUiLCJtYXRjaGVzIiwiaXNJZnJhbWUiLCJvbkNvbGxhYm9yYXRpb24iLCJyZWYiLCJmcmFtZVdpbmRvdyIsImNvbnRlbnRXaW5kb3ciLCJmcmFtZURvY3VtZW50IiwiY29udGVudERvY3VtZW50Iiwic2V0IiwiSFRNTEVsZW1lbnQiLCJwcm90b3R5cGUiLCJnZXRBbGxTZWxlY3RlZE9wdGlvbnMiLCJvcHRpb25zIiwibyIsImdldEFsbE9wdGlvbnMiLCJlIiwiZWxlbWVudHMiLCJzdGF0dXMiLCJfX2FkZFRvRWxlbWVudCIsIl9fcmVtb3ZlVG9FbGVtZW50IiwiaW5wdXRzIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJvdXJJbnB1dEluZGV4IiwiaW5kZXhPZiIsInNlbGVjdGVkT3B0aW9ucyIsImdldFNlbGVjdE9wdGlvbnMiLCJ1blNlbGVjdGVkT3B0aW9ucyIsInNlbGVjdGVkT3B0aW9uczIiLCJzZWxlY3RvciIsInB1c2giLCJhdHRyaWJ1dGVOYW1lIiwicGFyZW50RWxlbWVudCIsImNvbm5lY3RlZElucHV0IiwicXVlcnkiLCJpbmNsdWRlcyIsInBhcnNlQ2xhc3NMaXN0IiwiaXNTdWJzZXQiLCJvYmoxIiwib2JqMiIsIk9iamVjdCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsIm11bHRpcGxlIiwicGFyc2VkQ3NzIiwiZWxlbWVudFN0eWxlIiwic3R5bGUiLCJjbGFzc0xpc3QiLCJ0YXJnZXRDbGFzc0xpc3QiLCJldmVyeSIsImNsYXNzTmFtZSIsInRvU3RyaW5nIiwiaW5uZXJUZXh0IiwidmFsdWVzIiwiY29sbGFib3JhdGUiLCJtZXRob2QiLCJhc3NpZ24iLCJjbGFzc25hbWUiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJrZXlzIiwicmVtb3ZlIiwic2VsZWN0Iiwic3RhdGUiLCJ1bmRlZmluZWQiLCJzZWxlY3RlZCIsImlzT2JqZWN0RXF1YWwiLCJvYmplY3QxIiwib2JqZWN0MiIsImkiLCJsZW4iLCJsZW5ndGgiLCJwYXJzZWQiLCJjb250YWlucyIsInNlbE9wdGlvbnMiLCJzZWxPcHRpb25zMiIsIkNvQ3JlYXRlU2VsZWN0IiwicmVuZGVyVmFsdWUiLCJDb0NyZWF0ZVNvY2tldCIsImxpc3RlbiIsImRhdGEiLCJpc0FycmF5IiwiQ29DcmVhdGUiLCJzZW5kTWVzc2FnZSIsImJyb2FkY2FzdF9zZW5kZXIiLCJyb29tcyIsImVtaXQiLCJtZXNzYWdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBLENBQUMsWUFBTTtBQUNMO0FBRUEsTUFBSUEsT0FBTyxHQUFHLEVBQWQ7QUFDQSxNQUFJQyxTQUFTLEdBQUcsSUFBSUMsR0FBSixFQUFoQjtBQUNBLE1BQUlDLEtBQUssR0FBRyxFQUFaO0FBQ0FDLEVBQUFBLE1BQU0sQ0FBQ0MsV0FBUCxHQUFxQjtBQUFFQyxJQUFBQSxJQUFJLEVBQUpBLElBQUY7QUFBUUMsSUFBQUEsU0FBUyxFQUFUQTtBQUFSLEdBQXJCLENBTkssQ0FRTDs7QUFDQUgsRUFBQUEsTUFBTSxDQUFDSSxnQkFBUCxDQUF3QixNQUF4QixFQUFnQyxZQUFNO0FBQ3BDRixJQUFBQSxJQUFJLENBQUM7QUFBRUcsTUFBQUEsWUFBWSxFQUFFTCxNQUFoQjtBQUF3Qk0sTUFBQUEsU0FBUyxFQUFFQztBQUFuQyxLQUFELENBQUo7QUFDQVAsSUFBQUEsTUFBTSxDQUFDUSxnQkFBUCxDQUF3QkMsR0FBeEIsQ0FBNEI7QUFDMUJDLE1BQUFBLE9BQU8sRUFBRSxDQUFDLFlBQUQsRUFBZSxlQUFmLENBRGlCO0FBRTFCQyxNQUFBQSxJQUFJLEVBQUUsY0FBQ0MsUUFBRDtBQUFBLGVBQWNDLHNCQUFzQixDQUFDRCxRQUFELENBQXBDO0FBQUE7QUFGb0IsS0FBNUI7QUFLQVosSUFBQUEsTUFBTSxDQUFDUSxnQkFBUCxDQUF3QkMsR0FBeEIsQ0FBNEI7QUFDMUJLLE1BQUFBLElBQUksRUFBRSxhQURvQjtBQUUxQkosTUFBQUEsT0FBTyxFQUFFLENBQUMsWUFBRCxDQUZpQjtBQUcxQkssTUFBQUEsVUFBVSxFQUFFLENBQUMsdUJBQUQs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V0FBVCxDQUFxQjtBQUNuQkMsTUFBQUEsZ0JBQWdCLEVBQUUsS0FEQztBQUVuQkMsTUFBQUEsS0FBSyxFQUFFLEVBRlk7QUFHbkJDLE1BQUFBLElBQUksRUFBRTtBQUNKQyxRQUFBQSxPQUFPLEVBQUUsYUFETDtBQUVKUCxRQUFBQSxJQUFJLGtDQUNDQSxJQUREO0FBRUZ4SCxVQUFBQSxPQUFPLEVBQUV3SCxJQUFJLENBQUN4SCxPQUFMLENBQWFELFlBQWIsQ0FBMEIsaUJBQTFCO0FBRlA7QUFGQTtBQUhhLEtBQXJCO0FBV0Q7QUFDRixDQXJqQkQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlZmFjdG9yOlxuICogcmVmYWN0b3IgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gYSBjb21wb25lbnRcbiAqIHJlZmFjdG9yIGNjX3NlbGVjdF91dGlsaXR5LCBhbGxGcmFtZSwgcGFyc2VDc3NSdWxlcywgcGFyc2VDbGFzc0xpc3QgdG8gYSBnbG9iYWwvZ2VuZXJhbCB3b3Jrc3BhY2VcbiAqL1xuXG5cbigoKSA9PiB7XG4gIC8vc3RvcmUgYWxsIGZyYW1lc1xuXG4gIGxldCBmaWx0ZXJzID0gW107XG4gIGxldCBhbGxGcmFtZXMgPSBuZXcgTWFwKCk7XG4gIGxldCB0b29scyA9IHt9O1xuICB3aW5kb3cuY2NBdHRyaWJ1dGUgPSB7IGluaXQsIGFkZEZpbHRlciB9O1xuXG4gIC8vIGZpcnN0IHRpbWUgbG9hZFxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgIGluaXQoeyB3aW5kb3dPYmplY3Q6IHdpbmRvdywgZG9jT2JqZWN0OiBkb2N1bWVudCB9KTtcbiAgICB3aW5kb3cuQ29DcmVhdGVPYnNlcnZlci5hZGQoe1xuICAgICAgb2JzZXJ2ZTogW1wiYXR0cmlidXRlc1wiLCBcImNoYXJhY3RlckRhdGFcIl0sXG4gICAgICB0YXNrOiAobXV0YXRpb24pID0+IHRyaWdnZXJFbGVtZW50TXV0YXRpb24obXV0YXRpb24pLFxuICAgIH0pO1xuXG4gICAgd2luZG93LkNvQ3JlYXRlT2JzZXJ2ZXIuYWRkKHtcbiAgICAgIG5hbWU6IFwiY2NBdHRyaWJ1dGVcIixcbiAgICAgIG9ic2VydmU6IFtcImF0dHJpYnV0ZXNcIl0sXG4gICAgICBhdHRyaWJ1dGVzOiBbXCJkYXRhLWF0dHJpYnV0ZV90YXJnZXRcIl0sXG4gICAgICB0YXNrOiAobXV0YXRpb24pID0+IHVwZGF0ZUlucHV0KG11dGF0aW9uLnRhcmdldCksXG4gICAgfSk7XG4gICAgYWxsRnJhbWUoKGZyYW1lKSA9PlxuICAgICAgZnJhbWUucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWF0dHJpYnV0ZV90YXJnZXRdXCIpXG4gICAgKS5mb3JFYWNoKChpbnB1dCkgPT4gdXBkYXRlSW5wdXQoaW5wdXQpKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW5wdXQoaW5wdXQpIHtcbiAgICBjb25zdCBlbFNlbGVjdG9ySWQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWF0dHJpYnV0ZV90YXJnZXRcIik7XG4gICAgaWYgKCFlbFNlbGVjdG9ySWQpIHJldHVybjtcblxuICAgIGxldCBlbGVtZW50ID0gYWxsRnJhbWUoKGZyYW1lKSA9PiBmcmFtZS5xdWVyeVNlbGVjdG9yKGVsU2VsZWN0b3JJZCkpWzBdO1xuXG4gICAgbGV0IHJlYWQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWF0dHJpYnV0ZV9zeW5jXCIpO1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKHJlYWQpKVxuICAgICAgZnJvbUlucHV0KGlucHV0LCAodHlwZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLmNsYXNzID09PSBcInRvZ2dsZVwiKVxuICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSBmcm9tRWxlbWVudFRvQm9vbGVhbih7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBpbnB1dFZhbHVlOiBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSxcbiAgICAgICAgICAgIHJlYWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LnRhZ05hbWUgPT0gXCJTRUxFQ1RcIikge1xuICAgICAgICAgIGZyb21FbGVtZW50VG9TZWxlY3QoeyBpbnB1dCwgZWxlbWVudCwgcmVhZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC50YWdOYW1lID09IFwiQ09DUkVBVEUtU0VMRUNUXCIpIHtcbiAgICAgICAgICBmcm9tRWxlbWVudFRvQ0NTZWxlY3QoeyBpbnB1dCwgZWxlbWVudCwgcmVhZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5sYXN0VmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IGZyb21FbGVtZW50VG9UZXh0KHsgZWxlbWVudCwgcmVhZCB9KTtcbiAgICAgICAgICAvLyB0b2RvOiB1cCBvciBib3R0b20gaXMgY29ycmVjdCB3aGljaCBvbmU/XG4gICAgICAgICAgLy9pbnB1dC52YWx1ZSA9IGZyb21FbGVtZW50VG9UZXh0KHsgZWxlbWVudCwgcmVhZCB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUNzc1J1bGVzKHN0cikge1xuICAgIGxldCBzdHlsZU9iamVjdCA9IHt9O1xuICAgIGlmIChzdHIuc3BsaXQpXG4gICAgICBzdHIuc3BsaXQoXCI7XCIpLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICAgICAgbGV0IHJ1bGVTcGxpdCA9IHJ1bGUuc3BsaXQoXCI6XCIpO1xuICAgICAgICBsZXQga2V5ID0gcnVsZVNwbGl0LnNoaWZ0KCkudHJpbSgpO1xuICAgICAgICBsZXQgdmFsdWUgPSBydWxlU3BsaXQuam9pbigpLnRyaW0oKTtcbiAgICAgICAgaWYgKGtleSkgc3R5bGVPYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHBhcnNlQ3NzUnVsZXNBc0FycmF5KHN0cikge1xuICAgIGlmIChzdHIuc3BsaXQpXG4gICAgICByZXR1cm4gc3RyLnNwbGl0KFwiO1wiKS5zbGljZSgwLC0xKS5tYXAoc3QgPT4gc3QudHJpbSgpKVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBcblxuICBmdW5jdGlvbiBhbGxGcmFtZShjYWxsYmFjaykge1xuICAgIGxldCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgW2ZyYW1lT2JqZWN0LCBmcmFtZV0gb2YgYWxsRnJhbWVzKSB7XG4gICAgICBsZXQgY2FsbGJhY2tSZXN1bHQgPSBjYWxsYmFjayhmcmFtZS5kb2N1bWVudCwgZnJhbWUud2luZG93KTtcbiAgICAgIGlmIChcbiAgICAgICAgY2FsbGJhY2tSZXN1bHQgJiZcbiAgICAgICAgdHlwZW9mIGNhbGxiYWNrUmVzdWx0W1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgKVxuICAgICAgICBjYWxsYmFja1Jlc3VsdC5mb3JFYWNoKChlbCkgPT4gcmVzdWx0LmFkZChlbCkpO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2tSZXN1bHQpIHJlc3VsdC5hZGQoY2FsbGJhY2tSZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5mcm9tKHJlc3VsdCkuZmlsdGVyKFxuICAgICAgKGVsKSA9PiAhZmlsdGVycy5zb21lKChmaWx0ZXIpID0+IGVsLm1hdGNoZXMoZmlsdGVyKSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdCh7IHdpbmRvd09iamVjdCwgZG9jT2JqZWN0LCBpc0lmcmFtZSwgZnJhbWUsIG9uQ29sbGFib3JhdGlvbiA9ICgpID0+IHt9IH0pIHtcbiAgICBsZXQgcmVmO1xuICAgIHRvb2xzLm9uQ29sbGFib3JhdGlvbiA9IG9uQ29sbGFib3JhdGlvbjtcbiAgICBpZiAoaXNJZnJhbWUpIHtcbiAgICAgIGxldCBmcmFtZVdpbmRvdyA9IGZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgICBsZXQgZnJhbWVEb2N1bWVudCA9IGZyYW1lV2luZG93LmRvY3VtZW50IHx8IGZyYW1lLmNvbnRlbnREb2N1bWVudDtcblxuICAgICAgcmVmID0ge1xuICAgICAgICBmcmFtZSxcbiAgICAgICAgd2luZG93OiBmcmFtZVdpbmRvdyxcbiAgICAgICAgZG9jdW1lbnQ6IGZyYW1lRG9jdW1lbnQsXG4gICAgICAgIGlzSWZyYW1lOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIGFsbEZyYW1lcy5zZXQoZnJhbWUsIHJlZik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVmID0geyB3aW5kb3c6IHdpbmRvd09iamVjdCwgZG9jdW1lbnQ6IGRvY09iamVjdCwgaXNJZnJhbWU6IGZhbHNlIH07XG4gICAgICBhbGxGcmFtZXMuc2V0KFwibWFpblwiLCByZWYpO1xuICAgIH1cblxuICAgIHJlZi53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgcmVmLndpbmRvdy5Db0NyZWF0ZU9ic2VydmVyLmFkZCh7XG4gICAgICAgIG9ic2VydmU6IFtcImF0dHJpYnV0ZXNcIiwgXCJjaGFyYWN0ZXJEYXRhXCJdLFxuICAgICAgICB0YXNrOiAobXV0YXRpb24pID0+IHRyaWdnZXJFbGVtZW50TXV0YXRpb24obXV0YXRpb24pLFxuICAgICAgfSk7XG5cbiAgICAgIHJlZi53aW5kb3cuQ29DcmVhdGVPYnNlcnZlci5hZGQoe1xuICAgICAgICBuYW1lOiBcImNjQXR0cmlidXRlXCIsXG4gICAgICAgIG9ic2VydmU6IFtcImF0dHJpYnV0ZXNcIl0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IFtcImRhdGEtYXR0cmlidXRlX3RhcmdldFwiXSxcbiAgICAgICAgdGFzazogKG11dGF0aW9uKSA9PiB1cGRhdGVJbnB1dChtdXRhdGlvbi50YXJnZXQpLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZWYud2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZS5nZXRBbGxTZWxlY3RlZE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRBbGxTZWxlY3RlZE9wdGlvbnMoKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IFtzZWxlY3RlZF1cIik7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShvcHRpb25zKS5tYXAoKG8pID0+IG8uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikpO1xuICAgIH07XG4gICAgcmVmLndpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0QWxsT3B0aW9ucyA9IGZ1bmN0aW9uIGdldEFsbE9wdGlvbnMoKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IHVsID4gW3ZhbHVlXVwiKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG9wdGlvbnMpLm1hcCgobykgPT4gby5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSk7XG4gICAgfTtcbiAgXG5cbiAgICByZWYuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIChlKSA9PiB7XG4gICAgICBsZXQgaW5wdXQgPSBlLnRhcmdldDtcblxuICAgICAgY29uc3QgZWxTZWxlY3RvcklkID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1hdHRyaWJ1dGVfdGFyZ2V0XCIpO1xuICAgICAgaWYgKCFlbFNlbGVjdG9ySWQpIHJldHVybjtcbiAgICAgIGxldCBlbGVtZW50cyA9IGFsbEZyYW1lKChkb2N1bWVudCkgPT5cbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbFNlbGVjdG9ySWQpXG4gICAgICApO1xuXG4gICAgICBsZXQgcmVhZCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtYXR0cmlidXRlX3N5bmNcIik7XG5cbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgZnJvbUlucHV0KGlucHV0LCAodHlwZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICAgICAgICBsZXQgc3RhdHVzID0gaW5wdXRbbWV0YWRhdGEucmVhZF07XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSBfX2FkZFRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgdHlwZSwgcmVhZCk7XG4gICAgICAgICAgICBlbHNlIF9fcmVtb3ZlVG9FbGVtZW50KGlucHV0LCBlbGVtZW50LCB0eXBlLCByZWFkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgICAgICAgICBfX2FkZFRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgdHlwZSwgcmVhZCk7XG5cbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBhbGxGcmFtZSgoZnJhbWUpID0+XG4gICAgICAgICAgICAgIGZyYW1lLmdldEVsZW1lbnRzQnlOYW1lKGlucHV0Lm5hbWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5wdXRzID0gQXJyYXkuZnJvbShpbnB1dHMpO1xuICAgICAgICAgICAgbGV0IG91cklucHV0SW5kZXggPSBpbnB1dHMuaW5kZXhPZihpbnB1dCk7XG4gICAgICAgICAgICBpZiAob3VySW5wdXRJbmRleCAhPT0gLTEpIGRlbGV0ZSBpbnB1dHNbb3VySW5wdXRJbmRleF07XG5cbiAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQpIF9fcmVtb3ZlVG9FbGVtZW50KGlucHV0LCBlbGVtZW50LCB0eXBlLCByZWFkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS50eXBlID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRPcHRpb25zID0gZ2V0U2VsZWN0T3B0aW9ucyhpbnB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICBsZXQgdW5TZWxlY3RlZE9wdGlvbnMgPSBnZXRTZWxlY3RPcHRpb25zKGlucHV0LCBmYWxzZSk7XG5cbiAgICAgICAgICAgIF9fYWRkVG9FbGVtZW50KGlucHV0LCBlbGVtZW50LCBzZWxlY3RlZE9wdGlvbnMsIHJlYWQpO1xuICAgICAgICAgICAgX19yZW1vdmVUb0VsZW1lbnQoaW5wdXQsIGVsZW1lbnQsIHVuU2VsZWN0ZWRPcHRpb25zLCByZWFkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEudHlwZSA9PT0gXCJjb2NyZWF0ZS1zZWxlY3RcIikge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkT3B0aW9uczIgPSBpbnB1dC5nZXRBbGxTZWxlY3RlZE9wdGlvbnMoKTtcbiAgICAgICAgICAgIC8vIGxldCB1blNlbGVjdGVkT3B0aW9uczIgPSBpbnB1dFxuICAgICAgICAgICAgLy8gICAuZ2V0QWxsT3B0aW9ucygpXG4gICAgICAgICAgICAvLyAgIC5maWx0ZXIoKG8pID0+ICFzZWxlY3RlZE9wdGlvbnMyLmluY2x1ZGVzKG8pKTtcblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBfX2FkZFRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgc2VsZWN0ZWRPcHRpb25zMiwgcmVhZCk7XG4gICAgICAgICAgICAvLyBfX3JlbW92ZVRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgdW5TZWxlY3RlZE9wdGlvbnMyLCByZWFkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfX3JlbW92ZVRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgXCJsYXN0VmFsdWVcIiwgcmVhZCk7XG4gICAgICAgICAgICBfX2FkZFRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgdHlwZSwgcmVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gaWYgKGlucHV0LnRhZ05hbWUgPT09IFwiQ09DUkVBVEUtU0VMRUNUXCIgJiYgIWlucHV0LnNlbGVjdE9wdGlvbikge1xuICAvLyAgIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhjb2NyZWF0ZVV0aWxpdHkpKSB7XG4gIC8vICAgICBpbnB1dFtrXSA9IHY7XG4gIC8vICAgfVxuICAvLyB9XG5cbiAgZnVuY3Rpb24gYWRkRmlsdGVyKHNlbGVjdG9yKSB7XG4gICAgZmlsdGVycy5wdXNoKHNlbGVjdG9yKTtcbiAgfVxuXG4gIC8vIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAvLyAgIC8vYWRkIGNjX3NlbGVjdF91dGlsaXR5XG4gIC8vICAgaWYgKGlucHV0LnRhZ05hbWUgPT09IFwiQ09DUkVBVEUtU0VMRUNUXCIpIHtcbiAgLy8gICAgIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhjb2NyZWF0ZVV0aWxpdHkpKSB7XG4gIC8vICAgICAgIGlucHV0W2tdID0gdjtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgaW5wdXRBZGRFdmVudExpc3RlbmVyKGlucHV0KVxuICAvLyB9KTtcblxuICBmdW5jdGlvbiB0cmlnZ2VyRWxlbWVudE11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgbGV0IGVsZW1lbnQ7XG4gICAgbGV0IGF0dHJpYnV0ZU5hbWU7XG5cbiAgICBzd2l0Y2ggKG11dGF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJhdHRyaWJ1dGVzXCI6XG4gICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICBlbGVtZW50ID0gbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjaGFyYWN0ZXJEYXRhXCI6XG4gICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcImlubmVyVGV4dFwiO1xuICAgICAgICBlbGVtZW50ID0gbXV0YXRpb24udGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQgfHwgIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1hdHRyaWJ1dGVfc3luY1wiKSkpIHJldHVybjtcblxuICAgIGxldCBjb25uZWN0ZWRJbnB1dCA9IGFsbEZyYW1lKChmcmFtZSkgPT5cbiAgICAgIGZyYW1lLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1hdHRyaWJ1dGVfdGFyZ2V0XVwiKVxuICAgICkuZmlsdGVyKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtYXR0cmlidXRlX3N5bmNcIikgIT09IGF0dHJpYnV0ZU5hbWUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGxldCBxdWVyeSA9IGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtYXR0cmlidXRlX3RhcmdldFwiKTtcbiAgICAgIGxldCBlbGVtZW50cyA9IGFsbEZyYW1lKChmcmFtZSkgPT4gZnJhbWUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgY29ubmVjdGVkSW5wdXQuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIGxldCByZWFkID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1hdHRyaWJ1dGVfc3luY1wiKTtcbiAgICAgIGlmIChyZWFkID09PSBhdHRyaWJ1dGVOYW1lKVxuICAgICAgICBmcm9tSW5wdXQoaW5wdXQsICh0eXBlLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5jbGFzcyA9PT0gXCJ0b2dnbGVcIilcbiAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSBmcm9tRWxlbWVudFRvQm9vbGVhbih7XG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSxcbiAgICAgICAgICAgICAgcmVhZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsc2UgaWYgKGlucHV0LnRhZ05hbWUgPT0gXCJTRUxFQ1RcIikge1xuICAgICAgICAgICAgZnJvbUVsZW1lbnRUb1NlbGVjdCh7IGlucHV0LCBlbGVtZW50LCByZWFkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpbnB1dC50YWdOYW1lID09IFwiQ09DUkVBVEUtU0VMRUNUXCIpIHtcbiAgICAgICAgICAgIGZyb21FbGVtZW50VG9DQ1NlbGVjdCh7IGlucHV0LCBlbGVtZW50LCByZWFkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpbnB1dFZhbHVlID0gZnJvbUVsZW1lbnRUb1RleHQoeyBlbGVtZW50LCByZWFkIH0pO1xuICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlLnRyaW0oKSA9PSBpbnB1dFZhbHVlKSByZXR1cm47XG4gICAgICAgICAgICBpbnB1dC5sYXN0VmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDbGFzc0xpc3Qoc3RyKSB7XG4gICAgaWYgKHN0ci5zcGxpdCkgcmV0dXJuIHN0ci5zcGxpdChcIiBcIikubWFwKHN0ID0+IHN0LnRyaW0oKSk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTdWJzZXQob2JqMSwgb2JqMikge1xuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmoyKSkge1xuICAgICAgaWYgKG9iajFba2V5XSAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSW5wdXQoaW5wdXQsIGNhbGxiYWNrKSB7XG4gICAgc3dpdGNoIChpbnB1dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICBzd2l0Y2ggKGlucHV0LnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICAgIGNhbGxiYWNrKFwidmFsdWVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICAgIGNhbGxiYWNrKFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICBjbGFzczogXCJ0b2dnbGVcIixcbiAgICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICByZWFkOiBcImNoZWNrZWRcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgICBjYWxsYmFjayhcInZhbHVlXCIsIHtcbiAgICAgICAgICAgICAgY2xhc3M6IFwidG9nZ2xlXCIsXG4gICAgICAgICAgICAgIHR5cGU6IFwicmFkaW9cIixcbiAgICAgICAgICAgICAgcmVhZDogXCJjaGVja2VkXCIsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrKFwidmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGNhbGxiYWNrKFwidmFsdWVcIiwge1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgICAgICAgY2xhc3M6IGlucHV0Lm11bHRpcGxlID8gXCJtdWx0aXNlbGVjdFwiIDogXCJzZWxlY3RcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGNhbGxiYWNrKFwidmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvY3JlYXRlLXNlbGVjdFwiOlxuICAgICAgICBjYWxsYmFjayhcIkNPQ1JFQVRFLVNFTEVDVFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJjb2NyZWF0ZS1zZWxlY3RcIixcbiAgICAgICAgICBjbGFzczogaW5wdXQubXVsdGlwbGUgPyBcIm11bHRpc2VsZWN0XCIgOiBcInNlbGVjdFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaW5wdXQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICE9PSBudWxsKVxuICAgICAgICAgIGNhbGxiYWNrKFwiaW5uZXJUZXh0XCIpO1xuICAgICAgICBlbHNlIGNhbGxiYWNrKFwidmFsdWVcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUVsZW1lbnRUb0Jvb2xlYW4oeyBpbnB1dCwgZWxlbWVudCwgaW5wdXRWYWx1ZSwgcmVhZCB9KSB7XG4gICAgc3dpdGNoIChyZWFkKSB7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgbGV0IHBhcnNlZENzcyA9IHBhcnNlQ3NzUnVsZXMoaW5wdXRWYWx1ZSk7XG4gICAgICAgIGxldCBlbGVtZW50U3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXG4gICAgICAgIHJldHVybiBpc1N1YnNldChlbGVtZW50U3R5bGUsIHBhcnNlZENzcyk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgbGV0IGNsYXNzTGlzdCA9IHBhcnNlQ2xhc3NMaXN0KGlucHV0VmFsdWUpO1xuICAgICAgICBsZXQgdGFyZ2V0Q2xhc3NMaXN0ID0gQXJyYXkuZnJvbShlbGVtZW50LmNsYXNzTGlzdCk7XG4gICAgICAgIHJldHVybiBjbGFzc0xpc3QuZXZlcnkoKGNsYXNzTmFtZSkgPT5cbiAgICAgICAgICB0YXJnZXRDbGFzc0xpc3QuaW5jbHVkZXMoY2xhc3NOYW1lKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKHJlYWQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21FbGVtZW50VG9UZXh0KHsgZWxlbWVudCwgcmVhZCB9KSB7XG4gICAgc3dpdGNoIChyZWFkKSB7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKHJlYWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QudG9TdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgICAgIHJldHVybiBlbGVtZW50LmlubmVyVGV4dDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShyZWFkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX2FkZFRvRWxlbWVudChpbnB1dCwgZWxlbWVudCwgdHlwZSwgcmVhZCwgdmFsdWVzKSB7XG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIikgdmFsdWVzID0gdHlwZTtcbiAgICAgIGVsc2UgdmFsdWVzID0gW2lucHV0LmdldEF0dHJpYnV0ZSh0eXBlKSB8fCBpbnB1dFt0eXBlXV07XG4gICAgICBjb2xsYWJvcmF0ZSh7IG1ldGhvZDogXCJhZGRcIiwgdmFsdWVzLCBlbGVtZW50LCB0eXBlLCByZWFkIH0pO1xuICAgIH1cbiAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIHN3aXRjaCAocmVhZCkge1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG4gICAgICAgICAgbGV0IHBhcnNlZENzcyA9IHBhcnNlQ3NzUnVsZXModmFsdWUpO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgcGFyc2VkQ3NzKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAvLyB2YWx1ZVxuICAgICAgICAgIC8vICAgLnNwbGl0KFwiIFwiKVxuICAgICAgICAgIC8vICAgLmZvckVhY2goKGNsYXNzbmFtZSkgPT4gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzbmFtZSkpO1xuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgLnNwbGl0KFwiIFwiKVxuICAgICAgICAgICAgLmZvckVhY2goXG4gICAgICAgICAgICAgIChjbGFzc25hbWUpID0+IGNsYXNzbmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NuYW1lKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgICAgICAgZWxlbWVudFtyZWFkXSA9IHZhbHVlO1xuICAgICAgICAgIHRyaWdnZXJFbGVtZW50TXV0YXRpb24oe1xuICAgICAgICAgICAgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IHsgcGFyZW50RWxlbWVudDogZWxlbWVudCB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShyZWFkLCB2YWx1ZSk7XG4gICAgICAgICAgZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShyZWFkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9fcmVtb3ZlVG9FbGVtZW50KGlucHV0LCBlbGVtZW50LCB0eXBlLCByZWFkLCB2YWx1ZXMpIHtcbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiKSB2YWx1ZXMgPSB0eXBlO1xuICAgICAgZWxzZSB2YWx1ZXMgPSBbaW5wdXQuZ2V0QXR0cmlidXRlKHR5cGUpIHx8IGlucHV0W3R5cGVdXTtcbiAgICAgIGNvbGxhYm9yYXRlKHsgbWV0aG9kOiBcInJlbW92ZVwiLCB2YWx1ZXMsIGVsZW1lbnQsIHR5cGUsIHJlYWQgfSk7XG4gICAgfVxuICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgc3dpdGNoIChyZWFkKSB7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgICBsZXQgcGFyc2VkQ3NzID0gcGFyc2VDc3NSdWxlcyh2YWx1ZSk7XG4gICAgICAgICAgT2JqZWN0LmtleXMocGFyc2VkQ3NzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJzZWRDc3Nba2V5XSkgZWxlbWVudC5zdHlsZVtrZXldID0gXCJcIjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAvLyB2YWx1ZVxuICAgICAgICAgIC8vICAgLnNwbGl0KFwiIFwiKVxuICAgICAgICAgIC8vICAgLmZvckVhY2goKGNsYXNzbmFtZSkgPT4gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzbmFtZSkpO1xuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgLnNwbGl0KFwiIFwiKVxuICAgICAgICAgICAgLmZvckVhY2goXG4gICAgICAgICAgICAgIChjbGFzc25hbWUpID0+IGNsYXNzbmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NuYW1lKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHJlYWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0T3B0aW9ucyhzZWxlY3QsIHN0YXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBBcnJheS5mcm9tKHNlbGVjdC5vcHRpb25zKTtcbiAgICByZXR1cm4gb3B0aW9uc1xuICAgICAgLmZpbHRlcigobykgPT4gKHN0YXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogby5zZWxlY3RlZCA9PSBzdGF0ZSkpXG4gICAgICAubWFwKChvKSA9PiBvLnZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0RXF1YWwob2JqZWN0MSwgb2JqZWN0Mikge1xuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3QxKSlcbiAgICAgIGlmIChvYmplY3QxW2tleV0gIT09IG9iamVjdDJba2V5XSB8fCBvYmplY3QxW2tleV0gPT09IFwiXCIpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUVsZW1lbnRUb1NlbGVjdCh7IGlucHV0LCBlbGVtZW50LCByZWFkIH0pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaW5wdXQub3B0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc3dpdGNoIChyZWFkKSB7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIGxldCBwYXJzZWQgPSBwYXJzZUNzc1J1bGVzKGlucHV0Lm9wdGlvbnNbaV0udmFsdWUpO1xuXG4gICAgICAgICAgaWYgKGlzT2JqZWN0RXF1YWwocGFyc2VkLCBlbGVtZW50LnN0eWxlKSlcbiAgICAgICAgICAgIGlucHV0Lm9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGVsc2UgaW5wdXQub3B0aW9uc1tpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIC8vIGlmKHVuU3R5bGUuc29tZShzdHlsZSA9PiBpc09iamVjdEVxdWFsKHBhcnNlZCwgc3R5bGUpKSlcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoaW5wdXQub3B0aW9uc1tpXS52YWx1ZSkpXG4gICAgICAgICAgICBpbnB1dC5vcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBlbHNlIGlucHV0Lm9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShyZWFkKSA9PSBpbnB1dC5vcHRpb25zW2ldLnZhbHVlKVxuICAgICAgICAgICAgaW5wdXQub3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgZWxzZSBpbnB1dC5vcHRpb25zW2ldLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUVsZW1lbnRUb0NDU2VsZWN0KHsgaW5wdXQsIGVsZW1lbnQsIHJlYWQgfSkge1xuICAgIGxldCBvcHRpb25zLCBzZWxPcHRpb25zID0gW10sIHNlbE9wdGlvbnMyO1xuXG4gICAgc3dpdGNoIChyZWFkKSB7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgLy8gb3B0aW9ucyA9IGlucHV0LmdldEFsbE9wdGlvbnMoKTtcblxuICAgICAgICAvLyBmb3IgKGxldCBpID0gMCwgbGVuID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyAgIGxldCBwYXJzZWQgPSBwYXJzZUNzc1J1bGVzKG9wdGlvbnNbaV0pO1xuXG4gICAgICAgIC8vICAgaWYgKGlzT2JqZWN0RXF1YWwocGFyc2VkLCBlbGVtZW50LnN0eWxlKSlcbiAgICAgICAgLy8gICAgIHNlbE9wdGlvbnMucHVzaCggb3B0aW9uc1tpXSApO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIENvQ3JlYXRlU2VsZWN0LnJlbmRlclZhbHVlKGlucHV0LCBzZWxPcHRpb25zKVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgICAgc2VsT3B0aW9uczIgPSBwYXJzZUNzc1J1bGVzQXNBcnJheShlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSlcbiAgICAgICAgICBDb0NyZWF0ZVNlbGVjdC5yZW5kZXJWYWx1ZShpbnB1dCwgc2VsT3B0aW9uczIpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgIC8vIG9wdGlvbnMgPSBpbnB1dC5nZXRBbGxPcHRpb25zKCk7XG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvcHRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKG9wdGlvbnNbaV0pKVxuICAgICAgICAvLyAgICAgc2VsT3B0aW9ucy5wdXNoKCBvcHRpb25zW2ldICk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gQ29DcmVhdGVTZWxlY3QucmVuZGVyVmFsdWUoaW5wdXQsIHNlbE9wdGlvbnMpXG4gICAgICAgICAgc2VsT3B0aW9uczIgPSBwYXJzZUNsYXNzTGlzdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSlcbiAgICAgICAgICBDb0NyZWF0ZVNlbGVjdC5yZW5kZXJWYWx1ZShpbnB1dCwgc2VsT3B0aW9uczIpXG4gICAgICAgIFxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShyZWFkKSlcbiAgICAgICAgICBDb0NyZWF0ZVNlbGVjdC5yZW5kZXJWYWx1ZShpbnB1dCwgZWxlbWVudC5nZXRBdHRyaWJ1dGUocmVhZCkpXG4gICAgICAgIC8vIHRvZG86IG1pZ2h0IGJyZWFrXG4gICAgICAgIC8vIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShyZWFkKSA9PSBvcHRpb25zW2ldKVxuICAgICAgICAvLyAgIGlucHV0LnNlbGVjdE9wdGlvbihvcHRpb25zW2ldKTtcbiAgICAgICAgLy8gZWxzZSBpbnB1dC51bnNlbGVjdE9wdGlvbihvcHRpb25zW2ldKTtcbiAgICB9XG5cbiAgfVxuXG4gIENvQ3JlYXRlU29ja2V0Lmxpc3RlbihcImNjQXR0cmlidXRlXCIsIGZ1bmN0aW9uKHtcbiAgICBtZXRob2QsXG4gICAgdmFsdWVzLFxuICAgIGVsZW1lbnQsXG4gICAgdHlwZSxcbiAgICByZWFkLFxuICB9KSB7XG4gICAgZWxlbWVudCA9IGFsbEZyYW1lKChmcmFtZSkgPT5cbiAgICAgIGZyYW1lLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1lbGVtZW50X2lkPVwiICsgZWxlbWVudCArIFwiXVwiKVxuICAgIClbMF07XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJhZGRcIikge1xuICAgICAgX19hZGRUb0VsZW1lbnQobnVsbCwgZWxlbWVudCwgdHlwZSwgcmVhZCwgdmFsdWVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0aG9kID09PSBcInJlbW92ZVwiKSB7XG4gICAgICBfX3JlbW92ZVRvRWxlbWVudChudWxsLCBlbGVtZW50LCB0eXBlLCByZWFkLCB2YWx1ZXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gY29sbGFib3JhdGUoZGF0YSkge1xuICAgIHRvb2xzLm9uQ29sbGFib3JhdGlvbih7XG4gICAgICB2YWx1ZTogQXJyYXkuaXNBcnJheShkYXRhLnZhbHVlcykgPyBkYXRhLnZhbHVlcy5qb2luKCcgJykgOiBkYXRhLnZhbHVlcyxcbiAgICAgIHJlYWQ6IGRhdGEucmVhZCxcbiAgICAgIGVsZW1lbnQ6IGRhdGEuZWxlbWVudCxcblxuICAgIH0pO1xuXG4gICAgQ29DcmVhdGUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgYnJvYWRjYXN0X3NlbmRlcjogZmFsc2UsXG4gICAgICByb29tczogXCJcIixcbiAgICAgIGVtaXQ6IHtcbiAgICAgICAgbWVzc2FnZTogXCJjY0F0dHJpYnV0ZVwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBlbGVtZW50OiBkYXRhLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50X2lkXCIpLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufSkoKTtcbiJdLCJmaWxlIjoiLi9zcmMvQ29DcmVhdGUtYXR0cmlidXRlcy5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/CoCreate-attributes.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/CoCreate-attributes.js");
/******/ })()
.default;
});