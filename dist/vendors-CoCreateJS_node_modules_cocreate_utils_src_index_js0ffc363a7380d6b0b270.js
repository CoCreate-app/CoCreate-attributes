/*! For license information please see vendors-CoCreateJS_node_modules_cocreate_utils_src_index_js0ffc363a7380d6b0b270.js.LICENSE.txt */
(this.webpackChunkCoCreate_attributes=this.webpackChunkCoCreate_attributes||[]).push([["vendors-CoCreateJS_node_modules_cocreate_utils_src_index_js"],{"../../CoCreateJS/node_modules/@cocreate/utils/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "generateUUID": () => (/* binding */ generateUUID),\n/* harmony export */   "isRealTime": () => (/* binding */ isRealTime),\n/* harmony export */   "getParentFromElement": () => (/* binding */ getParentFromElement),\n/* harmony export */   "isReadValue": () => (/* binding */ isReadValue),\n/* harmony export */   "isUpdateValue": () => (/* binding */ isUpdateValue),\n/* harmony export */   "isJsonString": () => (/* binding */ isJsonString),\n/* harmony export */   "getAttributes": () => (/* binding */ getAttributes),\n/* harmony export */   "checkValue": () => (/* binding */ checkValue),\n/* harmony export */   "allFrame": () => (/* binding */ allFrame),\n/* harmony export */   "cssPath": () => (/* binding */ cssPath),\n/* harmony export */   "getTopMostWindow": () => (/* binding */ getTopMostWindow),\n/* harmony export */   "findIframeFromElement": () => (/* binding */ findIframeFromElement),\n/* harmony export */   "getIframeFromPath": () => (/* binding */ getIframeFromPath),\n/* harmony export */   "configMatch": () => (/* binding */ configMatch),\n/* harmony export */   "configExecuter": () => (/* binding */ configExecuter),\n/* harmony export */   "UUID": () => (/* binding */ UUID),\n/* harmony export */   "parseTextToHtml": () => (/* binding */ parseTextToHtml),\n/* harmony export */   "splitBydelimiter": () => (/* binding */ splitBydelimiter),\n/* harmony export */   "joinBydelimiter": () => (/* binding */ joinBydelimiter),\n/* harmony export */   "isValidSelector": () => (/* binding */ isValidSelector),\n/* harmony export */   "getElementPath": () => (/* binding */ getElementPath),\n/* harmony export */   "isUsageY": () => (/* binding */ isUsageY),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Created by jin\n * 2020-04-03\n */\n\n\nfunction generateUUID(length = 36) {\n  // if (length == 10) {\n  //   var result           = \'\';\n  //   var characters       = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\';\n  //   var charactersLength = characters.length;\n  //   for ( var i = 0; i < length; i++ ) {\n  //     result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  //   }\n\n  //   var dd = new Date().toTimeString();\n  //   var random = dd.replace(/[\\W_]+/g, "").substr(0,6);\n  //   result += random;\n  //   return result;\n  // }\n\n  let d = new Date().getTime();\n  let d2 =\n    (window.performance &&\n      window.performance.now &&\n      window.performance.now() * 1000) ||\n    0;\n  let pattern = "uxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";\n\n  if (length <= pattern.length) {\n    pattern = pattern.substr(0, length);\n  }\n  else {\n    let add_len = length - pattern.length;\n    let sub_pattern = "-xxxyyxxx";\n\n    let group_n = Math.floor(add_len / sub_pattern.length);\n\n    for (let i = 0; i < group_n; i++) {\n      pattern += sub_pattern;\n    }\n\n    group_n = add_len - group_n * sub_pattern.length;\n    pattern += sub_pattern.substr(0, group_n);\n  }\n\n  let uuid = pattern.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16;\n    if (d > 0) {\n      var r = (d + r) % 16 | 0;\n      d = Math.floor(d / 16);\n    }\n    else {\n      var r = (d2 + r) % 16 | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n    return (c == "x" ? r : (r & 0x7) | 0x8).toString(16);\n  });\n  return uuid;\n}\n\nfunction isRealTime(element, parent_realTime) {\n  let realtime = element.getAttribute("data-realtime") || parent_realTime;\n  if (realtime === "false") {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getParentFromElement(element, parent_class, attributes) {\n  if (parent_class) {\n    if (element.classList.contains(parent_class)) {\n      return element;\n    }\n\n    let node = element.parentNode;\n    while (node != null && node.classList) {\n      if (node.classList.contains(parent_class)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n  }\n  else if (attributes) {\n    if (attributes.every((attr) => element.attributes.hasOwnProperty(attr))) {\n      return element;\n    }\n\n    let node = element.parentNode;\n    while (node != null && node.attributes) {\n      if (attributes.every((attr) => node.attributes.hasOwnProperty(attr))) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n  }\n\n  return false;\n}\n\nfunction isReadValue(element) {\n  return element.getAttribute("data-read_value") != "false";\n}\n\nfunction isUpdateValue(element) {\n  return element.getAttribute("data-update_value") != "false";\n}\n\nfunction isJsonString(str_data) {\n  try {\n    let json_data = JSON.parse(str_data);\n    if (typeof json_data === "object" && json_data != null) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n  catch (e) {\n    return false;\n  }\n}\n\nfunction getAttributes(element) {\n  return element.getAttributeNames().reduce((attrMap, name) => {\n    attrMap[name] = element.getAttribute(name);\n    return attrMap;\n  }, {});\n}\n\nfunction checkValue(value) {\n  if (!value) return false;\n  if (/{{\\s*([\\w\\W]+)\\s*}}/g.test(value)) {\n    return false;\n  }\n\n  return true;\n}\n// hosseins utills\n\n// function to go through all frames\nfunction allFrame(callback) {\n  let allFrames = [{ document, window }];\n  for (let frame of document.querySelectorAll("iframe")) {\n    let frameDocument = frame.contentDocument || frame.contentWindow.document;\n    let frameWindow = frame.contentWindow;\n    allFrames.push({\n      document: frameDocument,\n      window: frameWindow,\n      frameElement: frame,\n    });\n  }\n  let result = new Set();\n  for (let frame of allFrames) {\n    let callbackResult = callback(frame);\n    if (\n      callbackResult &&\n      typeof callbackResult[Symbol.iterator] === "function"\n    )\n      callbackResult.forEach((el) => result.add(el));\n    else if (callbackResult) result.add(callbackResult);\n  }\n\n  return Array.from(result);\n}\n\nfunction cssPath(node) {\n  let pathSplits = [];\n  do {\n    if (!node || !node.tagName) return false;\n    let pathSplit = node.tagName.toLowerCase();\n    if (node.id && node.tagName !== "BODY") pathSplit += "#" + node.id;\n\n    if (node.classList.length && node.tagName !== "BODY") {\n      node.classList.forEach((item) => {\n        if (item.indexOf(":") === -1) pathSplit += "." + item;\n      });\n    }\n\n    if (node.tagName !== "BODY" && node.parentNode) {\n      let index = Array.prototype.indexOf.call(\n        node.parentNode.children,\n        node\n      );\n      pathSplit += `:nth-child(${index + 1})`;\n    }\n\n    pathSplits.unshift(pathSplit);\n    node = node.parentNode;\n  } while (node.tagName !== "HTML");\n\n  return pathSplits.join(" > ");\n}\n\nfunction getTopMostWindow() {\n  let parentWindow = window;\n  while (parentWindow !== window.parent) parentWindow = window.parent;\n  return parentWindow;\n}\n\nfunction findIframeFromElement(windowObject, element) {\n  let frameElement;\n  allFrame((frame) => {\n    if (frame.document.contains(element)) frameElement = frame.frameElement;\n    // window.cc.findIframeFromElement(frame.window, element);\n  });\n  return frameElement;\n}\n\nfunction getIframeFromPath(path) {\n  let topWindow = getTopMostWindow;\n\n  path.forEach((selector) => {\n    if (topWindow) topWindow = topWindow.querySelector(selector);\n  });\n  return topWindow;\n}\n// DO NOT REMOVE\n\nfunction* configMatch(elementConfig, element) {\n  for (let config of elementConfig) {\n    // if (!Array.isArray(config.selector))\n    //   config.selector = [config.selector];\n\n    if (config.selector && element.matches(config.selector)) yield config;\n  }\n  return;\n}\n\n\n// export function configMatch2(elementConfig, element) {\n//   let result = [];\n//   for (let config of elementConfig) {\n//     if (config.selector && element.matches(config.selector)) result.push(config);\n//   }\n//   return result;\n// }\n\n// DO NOT REMOVE\n\n// an opiniated function uses configMatch2 to read configs\n// WARNING: the config iterated from top to bottom. for deseired effect elementConfig should be reveresed\n// typeof elementConfig: array of objects and every objects containing keys as false, true or a selector \n// element: the element to read attributes\n// key: the key in which is in elementConfig and on match onSuccess callback will be called\nfunction configExecuter(element, key, onSuccess, elementConfig) {\n  for (let config of configMatch(elementConfig || window.elementConfig, element))\n    if (config[key] === true) return onSuccess(element, config);\n    else if (config[key] === false) return false;\n  else if (config[key] === undefined) continue;\n  else if (isValidSelector(config[key]))\n    return onSuccess(element, config, true);\n  else console.warn("builder: wrong element config ", config);\n\n  return false;\n}\n\nfunction UUID(length = 10) {\n  var result = "";\n  var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";\n\n  var charactersLength = characters.length;\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  var d = new Date().toTimeString();\n  var random = d.replace(/[\\W_]+/g, "").substr(0, 6);\n  result += random;\n  return result;\n}\n\nfunction parseTextToHtml(text) {\n  let doc = new DOMParser().parseFromString(text, "text/html");\n  if (doc.head.children[0]) return doc.head.children[0];\n  else return doc.body.children[0];\n}\n\nfunction splitBydelimiter(str, delimiter) {\n  return str.split(delimiter).map((s) => s.trim());\n}\n\nfunction joinBydelimiter(str, delimiter) {\n  return str.map((s) => s.trim()).join(delimiter);\n}\n\nfunction isValidSelector(selector) {\n  try {\n    document.createDocumentFragment().querySelector(selector);\n  }\n  catch (error) {\n    return false;\n  }\n  return true;\n}\n\nfunction getElementPath(element, returnContext) {\n  let path = [];\n\n  let topWindow = window;\n  let iframeElement = findIframeFromElement(topWindow, element);\n  let p = cssPath(iframeElement);\n  if (p) path.unshift(p);\n\n  return returnContext ? { path, document: iframeElement || document } : path;\n  //todo: support for nested iframe\n  // while(iframeElement !== findIframeFromElement(topWindow,iframeElement))\n  // {\n  //   iframeElement = findIframeFromElement(topWindow,iframeElement);\n  //   path.unshift(cssPath(iframeElement))\n  // }\n}\n\nfunction isUsageY(input) {\n  if (this.isJsonString(input.getAttribute(\'data-collection\'))) {\n    return false;\n  }\n\n  if (this.isJsonString(input.getAttribute(\'name\'))) {\n    return false;\n  }\n\n  if ((input.tagName === "INPUT" && ["text", "email", "tel", "url"].includes(input.type)) || input.tagName === "TEXTAREA") {\n\n    if (!input.getAttribute(\'name\')) {\n      return false;\n    }\n    if (input.getAttribute("data-realtime") == "false") {\n      return false;\n    }\n\n    if (input.getAttribute("data-unique") === "true") {\n      return false;\n    }\n\n    if (input.type === \'password\') {\n      return false;\n    }\n\n    if (!this.isReadValue(input)) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  isUsageY,\n  getElementPath,\n  isValidSelector,\n  joinBydelimiter,\n  splitBydelimiter,\n  parseTextToHtml,\n  UUID,\n  configExecuter,\n  configMatch,\n  getIframeFromPath,\n  findIframeFromElement,\n  getTopMostWindow,\n  cssPath,\n  allFrame,\n  checkValue,\n  getAttributes,\n  isJsonString,\n  isUpdateValue,\n  isReadValue,\n  getParentFromElement,\n  isRealTime,\n  generateUUID\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5hdHRyaWJ1dGVzLy4uLy4uL0NvQ3JlYXRlSlMvbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS91dGlscy9zcmMvaW5kZXguanM/N2YyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFTztBQUNQO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiw0Q0FBNEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4uLy4uL0NvQ3JlYXRlSlMvbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS91dGlscy9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgamluXG4gKiAyMDIwLTA0LTAzXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKGxlbmd0aCA9IDM2KSB7XG4gIC8vIGlmIChsZW5ndGggPT0gMTApIHtcbiAgLy8gICB2YXIgcmVzdWx0ICAgICAgICAgICA9ICcnO1xuICAvLyAgIHZhciBjaGFyYWN0ZXJzICAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbiAgLy8gICB2YXIgY2hhcmFjdGVyc0xlbmd0aCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuICAvLyAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAvLyAgICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnNMZW5ndGgpKTtcbiAgLy8gICB9XG5cbiAgLy8gICB2YXIgZGQgPSBuZXcgRGF0ZSgpLnRvVGltZVN0cmluZygpO1xuICAvLyAgIHZhciByYW5kb20gPSBkZC5yZXBsYWNlKC9bXFxXX10rL2csIFwiXCIpLnN1YnN0cigwLDYpO1xuICAvLyAgIHJlc3VsdCArPSByYW5kb207XG4gIC8vICAgcmV0dXJuIHJlc3VsdDtcbiAgLy8gfVxuXG4gIGxldCBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGxldCBkMiA9XG4gICAgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJlxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyAmJlxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpICogMTAwMCkgfHxcbiAgICAwO1xuICBsZXQgcGF0dGVybiA9IFwidXh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCI7XG5cbiAgaWYgKGxlbmd0aCA8PSBwYXR0ZXJuLmxlbmd0aCkge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cigwLCBsZW5ndGgpO1xuICB9XG4gIGVsc2Uge1xuICAgIGxldCBhZGRfbGVuID0gbGVuZ3RoIC0gcGF0dGVybi5sZW5ndGg7XG4gICAgbGV0IHN1Yl9wYXR0ZXJuID0gXCIteHh4eXl4eHhcIjtcblxuICAgIGxldCBncm91cF9uID0gTWF0aC5mbG9vcihhZGRfbGVuIC8gc3ViX3BhdHRlcm4ubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBfbjsgaSsrKSB7XG4gICAgICBwYXR0ZXJuICs9IHN1Yl9wYXR0ZXJuO1xuICAgIH1cblxuICAgIGdyb3VwX24gPSBhZGRfbGVuIC0gZ3JvdXBfbiAqIHN1Yl9wYXR0ZXJuLmxlbmd0aDtcbiAgICBwYXR0ZXJuICs9IHN1Yl9wYXR0ZXJuLnN1YnN0cigwLCBncm91cF9uKTtcbiAgfVxuXG4gIGxldCB1dWlkID0gcGF0dGVybi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNjtcbiAgICBpZiAoZCA+IDApIHtcbiAgICAgIHZhciByID0gKGQgKyByKSAlIDE2IHwgMDtcbiAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHIgPSAoZDIgKyByKSAlIDE2IHwgMDtcbiAgICAgIGQyID0gTWF0aC5mbG9vcihkMiAvIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIChjID09IFwieFwiID8gciA6IChyICYgMHg3KSB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICB9KTtcbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlYWxUaW1lKGVsZW1lbnQsIHBhcmVudF9yZWFsVGltZSkge1xuICBsZXQgcmVhbHRpbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtcmVhbHRpbWVcIikgfHwgcGFyZW50X3JlYWxUaW1lO1xuICBpZiAocmVhbHRpbWUgPT09IFwiZmFsc2VcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCwgcGFyZW50X2NsYXNzLCBhdHRyaWJ1dGVzKSB7XG4gIGlmIChwYXJlbnRfY2xhc3MpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMocGFyZW50X2NsYXNzKSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKG5vZGUgIT0gbnVsbCAmJiBub2RlLmNsYXNzTGlzdCkge1xuICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKHBhcmVudF9jbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMuZXZlcnkoKGF0dHIpID0+IGVsZW1lbnQuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGxldCBub2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlICE9IG51bGwgJiYgbm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoYXR0cmlidXRlcy5ldmVyeSgoYXR0cikgPT4gbm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFkVmFsdWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlYWRfdmFsdWVcIikgIT0gXCJmYWxzZVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVcGRhdGVWYWx1ZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdXBkYXRlX3ZhbHVlXCIpICE9IFwiZmFsc2VcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSnNvblN0cmluZyhzdHJfZGF0YSkge1xuICB0cnkge1xuICAgIGxldCBqc29uX2RhdGEgPSBKU09OLnBhcnNlKHN0cl9kYXRhKTtcbiAgICBpZiAodHlwZW9mIGpzb25fZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBqc29uX2RhdGEgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZU5hbWVzKCkucmVkdWNlKChhdHRyTWFwLCBuYW1lKSA9PiB7XG4gICAgYXR0ck1hcFtuYW1lXSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiBhdHRyTWFwO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZhbHVlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgaWYgKC97e1xccyooW1xcd1xcV10rKVxccyp9fS9nLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vLyBob3NzZWlucyB1dGlsbHNcblxuLy8gZnVuY3Rpb24gdG8gZ28gdGhyb3VnaCBhbGwgZnJhbWVzXG5leHBvcnQgZnVuY3Rpb24gYWxsRnJhbWUoY2FsbGJhY2spIHtcbiAgbGV0IGFsbEZyYW1lcyA9IFt7IGRvY3VtZW50LCB3aW5kb3cgfV07XG4gIGZvciAobGV0IGZyYW1lIG9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpZnJhbWVcIikpIHtcbiAgICBsZXQgZnJhbWVEb2N1bWVudCA9IGZyYW1lLmNvbnRlbnREb2N1bWVudCB8fCBmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgIGxldCBmcmFtZVdpbmRvdyA9IGZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgYWxsRnJhbWVzLnB1c2goe1xuICAgICAgZG9jdW1lbnQ6IGZyYW1lRG9jdW1lbnQsXG4gICAgICB3aW5kb3c6IGZyYW1lV2luZG93LFxuICAgICAgZnJhbWVFbGVtZW50OiBmcmFtZSxcbiAgICB9KTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gbmV3IFNldCgpO1xuICBmb3IgKGxldCBmcmFtZSBvZiBhbGxGcmFtZXMpIHtcbiAgICBsZXQgY2FsbGJhY2tSZXN1bHQgPSBjYWxsYmFjayhmcmFtZSk7XG4gICAgaWYgKFxuICAgICAgY2FsbGJhY2tSZXN1bHQgJiZcbiAgICAgIHR5cGVvZiBjYWxsYmFja1Jlc3VsdFtTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCJcbiAgICApXG4gICAgICBjYWxsYmFja1Jlc3VsdC5mb3JFYWNoKChlbCkgPT4gcmVzdWx0LmFkZChlbCkpO1xuICAgIGVsc2UgaWYgKGNhbGxiYWNrUmVzdWx0KSByZXN1bHQuYWRkKGNhbGxiYWNrUmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHJlc3VsdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NQYXRoKG5vZGUpIHtcbiAgbGV0IHBhdGhTcGxpdHMgPSBbXTtcbiAgZG8ge1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS50YWdOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBhdGhTcGxpdCA9IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChub2RlLmlkICYmIG5vZGUudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHBhdGhTcGxpdCArPSBcIiNcIiArIG5vZGUuaWQ7XG5cbiAgICBpZiAobm9kZS5jbGFzc0xpc3QubGVuZ3RoICYmIG5vZGUudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHtcbiAgICAgIG5vZGUuY2xhc3NMaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGl0ZW0uaW5kZXhPZihcIjpcIikgPT09IC0xKSBwYXRoU3BsaXQgKz0gXCIuXCIgKyBpdGVtO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudGFnTmFtZSAhPT0gXCJCT0RZXCIgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBsZXQgaW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKFxuICAgICAgICBub2RlLnBhcmVudE5vZGUuY2hpbGRyZW4sXG4gICAgICAgIG5vZGVcbiAgICAgICk7XG4gICAgICBwYXRoU3BsaXQgKz0gYDpudGgtY2hpbGQoJHtpbmRleCArIDF9KWA7XG4gICAgfVxuXG4gICAgcGF0aFNwbGl0cy51bnNoaWZ0KHBhdGhTcGxpdCk7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfSB3aGlsZSAobm9kZS50YWdOYW1lICE9PSBcIkhUTUxcIik7XG5cbiAgcmV0dXJuIHBhdGhTcGxpdHMuam9pbihcIiA+IFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcE1vc3RXaW5kb3coKSB7XG4gIGxldCBwYXJlbnRXaW5kb3cgPSB3aW5kb3c7XG4gIHdoaWxlIChwYXJlbnRXaW5kb3cgIT09IHdpbmRvdy5wYXJlbnQpIHBhcmVudFdpbmRvdyA9IHdpbmRvdy5wYXJlbnQ7XG4gIHJldHVybiBwYXJlbnRXaW5kb3c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSWZyYW1lRnJvbUVsZW1lbnQod2luZG93T2JqZWN0LCBlbGVtZW50KSB7XG4gIGxldCBmcmFtZUVsZW1lbnQ7XG4gIGFsbEZyYW1lKChmcmFtZSkgPT4ge1xuICAgIGlmIChmcmFtZS5kb2N1bWVudC5jb250YWlucyhlbGVtZW50KSkgZnJhbWVFbGVtZW50ID0gZnJhbWUuZnJhbWVFbGVtZW50O1xuICAgIC8vIHdpbmRvdy5jYy5maW5kSWZyYW1lRnJvbUVsZW1lbnQoZnJhbWUud2luZG93LCBlbGVtZW50KTtcbiAgfSk7XG4gIHJldHVybiBmcmFtZUVsZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJZnJhbWVGcm9tUGF0aChwYXRoKSB7XG4gIGxldCB0b3BXaW5kb3cgPSBnZXRUb3BNb3N0V2luZG93O1xuXG4gIHBhdGguZm9yRWFjaCgoc2VsZWN0b3IpID0+IHtcbiAgICBpZiAodG9wV2luZG93KSB0b3BXaW5kb3cgPSB0b3BXaW5kb3cucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH0pO1xuICByZXR1cm4gdG9wV2luZG93O1xufVxuLy8gRE8gTk9UIFJFTU9WRVxuXG5leHBvcnQgZnVuY3Rpb24qIGNvbmZpZ01hdGNoKGVsZW1lbnRDb25maWcsIGVsZW1lbnQpIHtcbiAgZm9yIChsZXQgY29uZmlnIG9mIGVsZW1lbnRDb25maWcpIHtcbiAgICAvLyBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlnLnNlbGVjdG9yKSlcbiAgICAvLyAgIGNvbmZpZy5zZWxlY3RvciA9IFtjb25maWcuc2VsZWN0b3JdO1xuXG4gICAgaWYgKGNvbmZpZy5zZWxlY3RvciAmJiBlbGVtZW50Lm1hdGNoZXMoY29uZmlnLnNlbGVjdG9yKSkgeWllbGQgY29uZmlnO1xuICB9XG4gIHJldHVybjtcbn1cblxuXG4vLyBleHBvcnQgZnVuY3Rpb24gY29uZmlnTWF0Y2gyKGVsZW1lbnRDb25maWcsIGVsZW1lbnQpIHtcbi8vICAgbGV0IHJlc3VsdCA9IFtdO1xuLy8gICBmb3IgKGxldCBjb25maWcgb2YgZWxlbWVudENvbmZpZykge1xuLy8gICAgIGlmIChjb25maWcuc2VsZWN0b3IgJiYgZWxlbWVudC5tYXRjaGVzKGNvbmZpZy5zZWxlY3RvcikpIHJlc3VsdC5wdXNoKGNvbmZpZyk7XG4vLyAgIH1cbi8vICAgcmV0dXJuIHJlc3VsdDtcbi8vIH1cblxuLy8gRE8gTk9UIFJFTU9WRVxuXG4vLyBhbiBvcGluaWF0ZWQgZnVuY3Rpb24gdXNlcyBjb25maWdNYXRjaDIgdG8gcmVhZCBjb25maWdzXG4vLyBXQVJOSU5HOiB0aGUgY29uZmlnIGl0ZXJhdGVkIGZyb20gdG9wIHRvIGJvdHRvbS4gZm9yIGRlc2VpcmVkIGVmZmVjdCBlbGVtZW50Q29uZmlnIHNob3VsZCBiZSByZXZlcmVzZWRcbi8vIHR5cGVvZiBlbGVtZW50Q29uZmlnOiBhcnJheSBvZiBvYmplY3RzIGFuZCBldmVyeSBvYmplY3RzIGNvbnRhaW5pbmcga2V5cyBhcyBmYWxzZSwgdHJ1ZSBvciBhIHNlbGVjdG9yIFxuLy8gZWxlbWVudDogdGhlIGVsZW1lbnQgdG8gcmVhZCBhdHRyaWJ1dGVzXG4vLyBrZXk6IHRoZSBrZXkgaW4gd2hpY2ggaXMgaW4gZWxlbWVudENvbmZpZyBhbmQgb24gbWF0Y2ggb25TdWNjZXNzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG5leHBvcnQgZnVuY3Rpb24gY29uZmlnRXhlY3V0ZXIoZWxlbWVudCwga2V5LCBvblN1Y2Nlc3MsIGVsZW1lbnRDb25maWcpIHtcbiAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ01hdGNoKGVsZW1lbnRDb25maWcgfHwgd2luZG93LmVsZW1lbnRDb25maWcsIGVsZW1lbnQpKVxuICAgIGlmIChjb25maWdba2V5XSA9PT0gdHJ1ZSkgcmV0dXJuIG9uU3VjY2VzcyhlbGVtZW50LCBjb25maWcpO1xuICAgIGVsc2UgaWYgKGNvbmZpZ1trZXldID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICBlbHNlIGlmIChjb25maWdba2V5XSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgZWxzZSBpZiAoaXNWYWxpZFNlbGVjdG9yKGNvbmZpZ1trZXldKSlcbiAgICByZXR1cm4gb25TdWNjZXNzKGVsZW1lbnQsIGNvbmZpZywgdHJ1ZSk7XG4gIGVsc2UgY29uc29sZS53YXJuKFwiYnVpbGRlcjogd3JvbmcgZWxlbWVudCBjb25maWcgXCIsIGNvbmZpZyk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVVVJRChsZW5ndGggPSAxMCkge1xuICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgdmFyIGNoYXJhY3RlcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcblxuICB2YXIgY2hhcmFjdGVyc0xlbmd0aCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnNMZW5ndGgpKTtcbiAgfVxuXG4gIHZhciBkID0gbmV3IERhdGUoKS50b1RpbWVTdHJpbmcoKTtcbiAgdmFyIHJhbmRvbSA9IGQucmVwbGFjZSgvW1xcV19dKy9nLCBcIlwiKS5zdWJzdHIoMCwgNik7XG4gIHJlc3VsdCArPSByYW5kb207XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRleHRUb0h0bWwodGV4dCkge1xuICBsZXQgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCBcInRleHQvaHRtbFwiKTtcbiAgaWYgKGRvYy5oZWFkLmNoaWxkcmVuWzBdKSByZXR1cm4gZG9jLmhlYWQuY2hpbGRyZW5bMF07XG4gIGVsc2UgcmV0dXJuIGRvYy5ib2R5LmNoaWxkcmVuWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRCeWRlbGltaXRlcihzdHIsIGRlbGltaXRlcikge1xuICByZXR1cm4gc3RyLnNwbGl0KGRlbGltaXRlcikubWFwKChzKSA9PiBzLnRyaW0oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBqb2luQnlkZWxpbWl0ZXIoc3RyLCBkZWxpbWl0ZXIpIHtcbiAgcmV0dXJuIHN0ci5tYXAoKHMpID0+IHMudHJpbSgpKS5qb2luKGRlbGltaXRlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudFBhdGgoZWxlbWVudCwgcmV0dXJuQ29udGV4dCkge1xuICBsZXQgcGF0aCA9IFtdO1xuXG4gIGxldCB0b3BXaW5kb3cgPSB3aW5kb3c7XG4gIGxldCBpZnJhbWVFbGVtZW50ID0gZmluZElmcmFtZUZyb21FbGVtZW50KHRvcFdpbmRvdywgZWxlbWVudCk7XG4gIGxldCBwID0gY3NzUGF0aChpZnJhbWVFbGVtZW50KTtcbiAgaWYgKHApIHBhdGgudW5zaGlmdChwKTtcblxuICByZXR1cm4gcmV0dXJuQ29udGV4dCA/IHsgcGF0aCwgZG9jdW1lbnQ6IGlmcmFtZUVsZW1lbnQgfHwgZG9jdW1lbnQgfSA6IHBhdGg7XG4gIC8vdG9kbzogc3VwcG9ydCBmb3IgbmVzdGVkIGlmcmFtZVxuICAvLyB3aGlsZShpZnJhbWVFbGVtZW50ICE9PSBmaW5kSWZyYW1lRnJvbUVsZW1lbnQodG9wV2luZG93LGlmcmFtZUVsZW1lbnQpKVxuICAvLyB7XG4gIC8vICAgaWZyYW1lRWxlbWVudCA9IGZpbmRJZnJhbWVGcm9tRWxlbWVudCh0b3BXaW5kb3csaWZyYW1lRWxlbWVudCk7XG4gIC8vICAgcGF0aC51bnNoaWZ0KGNzc1BhdGgoaWZyYW1lRWxlbWVudCkpXG4gIC8vIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVXNhZ2VZKGlucHV0KSB7XG4gIGlmICh0aGlzLmlzSnNvblN0cmluZyhpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzSnNvblN0cmluZyhpbnB1dC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKGlucHV0LnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBbXCJ0ZXh0XCIsIFwiZW1haWxcIiwgXCJ0ZWxcIiwgXCJ1cmxcIl0uaW5jbHVkZXMoaW5wdXQudHlwZSkpIHx8IGlucHV0LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuXG4gICAgaWYgKCFpbnB1dC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZWFsdGltZVwiKSA9PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS11bmlxdWVcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0LnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNSZWFkVmFsdWUoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc1VzYWdlWSxcbiAgZ2V0RWxlbWVudFBhdGgsXG4gIGlzVmFsaWRTZWxlY3RvcixcbiAgam9pbkJ5ZGVsaW1pdGVyLFxuICBzcGxpdEJ5ZGVsaW1pdGVyLFxuICBwYXJzZVRleHRUb0h0bWwsXG4gIFVVSUQsXG4gIGNvbmZpZ0V4ZWN1dGVyLFxuICBjb25maWdNYXRjaCxcbiAgZ2V0SWZyYW1lRnJvbVBhdGgsXG4gIGZpbmRJZnJhbWVGcm9tRWxlbWVudCxcbiAgZ2V0VG9wTW9zdFdpbmRvdyxcbiAgY3NzUGF0aCxcbiAgYWxsRnJhbWUsXG4gIGNoZWNrVmFsdWUsXG4gIGdldEF0dHJpYnV0ZXMsXG4gIGlzSnNvblN0cmluZyxcbiAgaXNVcGRhdGVWYWx1ZSxcbiAgaXNSZWFkVmFsdWUsXG4gIGdldFBhcmVudEZyb21FbGVtZW50LFxuICBpc1JlYWxUaW1lLFxuICBnZW5lcmF0ZVVVSURcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../CoCreateJS/node_modules/@cocreate/utils/src/index.js\n')}}]);